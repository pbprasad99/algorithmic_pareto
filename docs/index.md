---
title: Home
---

# algorithmic_pareto

[WIP]  Algorithms and Data Structures - The Pareto Set

The absolute basics to master.

# philosophy

Broadly, I classify any algorithm or data structure into recursive or iterative. Of course, this is not a strict demarcation, but only in terms of the usual implementations.


As for data structures, there are two fundamental types in terms of how they are stored : contiguous storage (arrays, dynamic arrays) and linked storage (linked lists, trees, graphs) 

### mental models

To effectively use a concept, it helps greatly to have the right mental model which allows you to use it in a consistent manner.

For example, understanding and thinking of binary search in terms of bisect left and bisect right makes it easy to actually use it in a consistent manner.

Another example, for array partitioning, just thinking of and  defining the loop invariant correctly is key. 

My effort is always to develop the correct understanding and mental model for any concept.

### call a thing by its right name

Just knowing the name of a thing is very powerful.  Know the name of the problem and know the name of the algorithm.

<!-- BEGIN_DOCS_INDEX -->

# index

- [iterative](iterative)
  - [1_array_partitioning](iterative/1_array_partitioning)
    - [1_two_way_partition](iterative/1_array_partitioning/1_two_way_partition)
      - [1_Hoare](iterative/1_array_partitioning/1_two_way_partition/1_Hoare)
      - [2_Lomuto](iterative/1_array_partitioning/1_two_way_partition/2_Lomuto)
    - [2_three_way_partition](iterative/1_array_partitioning/2_three_way_partition)
      - [Djikstra](iterative/1_array_partitioning/2_three_way_partition/Djikstra)
    - [3_quick_select](iterative/1_array_partitioning/3_quick_select)
  - [2_binary_search](iterative/2_binary_search)
    - [problems](iterative/2_binary_search/problems)
      - [median_of_two_sorted_arrays](iterative/2_binary_search/problems/median_of_two_sorted_arrays)
- [recursive](recursive)
  - [1)basics](recursive/1)basics)
  - [2)backtracking](recursive/2)backtracking)

<!-- END_DOCS_INDEX -->



## Algorithm Categories

This repository contains implementations and explanations of various algorithms categorized by approach:

- **Iterative**: Algorithms that use loops and iterations
- **Recursive**: Algorithms that call themselves to solve subproblems
- **Dynamic Programming**: Algorithms that break down problems into simpler subproblems
- **Greedy**: Algorithms that make locally optimal choices at each step

## How to Use This Resource

Navigate through the sections to find detailed explanations, implementations, and complexity analysis for each algorithm.

