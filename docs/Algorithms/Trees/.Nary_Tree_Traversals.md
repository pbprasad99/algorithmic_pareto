# Nary Tree Depth First Traversals


## Preorder 

For an N-ary Tree, preorder traversal would mean :

1. Visit Root Node first
2. Visit child subtrees


## Postorder

For an N-ary tree, postorder traversal would mean :

1. Visit child Subtrees
2. Visit Root Node



## Inorder

The concept of an "inorder" traversal is intrinsically tied to the structure of a binary tree, which has a clear and distinct separation between a "left" subtree and a "right" subtree. The definition Left -> Node -> Right is unambiguous because there is only one "middle" place to visit the node: between its two children.

In an N-ary tree, there can be N children, so there is no clear distinction between left and right subtrees. Therefore there is no universally accepted convention of inorder traversal of an N-ary tree.

***(What follows can be safely skipped, I did it this because I like to torture myself sometimes.)***

However we could come up with a custom definition like this :

1. Visit First Child Subtree, 
2. Visit Root Node.
3. Visit the remaining child subtrees.


??? code "Custom Nary Tree Traversal"
    ```python
       """
       Traversal Order :
       Child_1 -> Node -> Remaining_Children
       """
       class Solution:

           def custom_inorder(self, root: 'Node') -> list[int]:
               result = []
               self._traverse(root, result)
               return result
           
           def _traverse(self, node: 'Node', result: list[int]):
               if not node:
                   return
       
               # 1. Traverse the first child's subtree (if it exists)
               if node.children:
                   self._traverse(node.children[0], result)
                   
               # 2. Visit the parent node
               result.append(node.val)
               
               # 3. Traverse the remaining children's subtrees (from the 2nd child onwards)
               if len(node.children) > 1:
                   for i in range(1, len(node.children)):
                       self._traverse(node.children[i], result)
    ```

For the iterative implementation, we will need to know for each node if its already visited.The most robust way to do this is to use a single stack that stores not just the nodes, but also a flag indicating their processing state. This perfectly simulates the recursive call stack.
The custom inorder rule is First Child -> Parent Node -> Remaining Children. To achieve this with a LIFO stack, we must push the items onto the stack in the reverse of the desired processing order.
The algorithm works as follows:

Initialize a stack. Push the root node onto it, paired with a False flag (meaning "not yet visited").
Loop while the stack is not empty.
Pop a (node, visited) pair.
If the visited flag is True, it means all of the node's required children have been processed. We can now simply visit the node by adding its value to our result list.
If the visited flag is False, it's the first time we are processing this node. We must defer visiting it and instead push its children and itself back onto the stack in the correct order for future processing. The push order will be:
First: The remaining children (child[1] to child[N]) in reverse order.
Second: The parent node itself, but this time paired with a True flag.
Last: The first child (child[0]).
Because we push the first child last, it will be the first item to be popped and processed, fulfilling the traversal's definition.

??? code "Iterative implementation of custom inorder traversal"
    ```python
    # Definition for a Node.
    class Node:
        def __init__(self, val=None, children=None):
            self.val = val
            self.children = children if children is not None else []
    
    class Solution:
        def custom_inorder_iterative(self, root: 'Node') -> list[int]:
            if not root:
                return []
    
            result = []
            # The stack will store tuples of (node, visited_flag)
            stack = [(root, False)]
    
            while stack:
                node, visited = stack.pop()
    
                if not node:
                    continue
    
                # If the node's visited_flag is True, it means its first child's
                # subtree has been fully processed. It's time to visit the node.
                if visited:
                    result.append(node.val)
                else:
                    # This is the first time we see this node.
                    # Push its children and itself back onto the stack in the
                    # reverse order of how we want to process them.
                    # Processing Order: First Child -> Parent -> Other Children
                    # Stack Push Order: Other Children -> Parent -> First Child
    
                    # 3. Push other children (from last to second)
                    if len(node.children) > 1:
                        for i in range(len(node.children) - 1, 0, -1):
                            stack.append((node.children[i], False))
    
                    # 2. Push the parent node itself, marked to be visited next
                    stack.append((node, True))
    
                    # 1. Push the first child (if it exists)
                    if node.children:
                        stack.append((node.children[0], False))
    
            return result
    ```


***This also a good place to discuss why we need this explicit state managment using a visited flag for each node in iterative implementation. The recursive implementation doesn't need a visited flag because the language's call stack provides state management for free, whereas the iterative solution must manage that state manually.***

Think of the process as having an "invisible bookmark" that remembers your exact place in the code.

In the recursive solution, the call stack is your automatic bookmark.

When the function _traverse(node) calls _traverse(node.children[0]), the execution of the parent _traverse(node) function is paused. The program's call stack saves everything about its current state, including:

* Its local variables (like node).
* Crucially, the exact line of code to return to after the child's call is completely finished.

```python
def _traverse(self, node: 'Node', result: list[int]):
    # ...
    # 1. Traverse the first child
    if node.children:
        self._traverse(node.children[0])  # <-- The program PAUSES here

    # <-- When the call above is done, the program AUTOMATICALLY resumes HERE
    
    # 2. Visit the parent node
    result.append(node.val)
    #
    # ...
```

What is to be done and with what data after the recursive call is implicitly KNOWN. The call stack inherently knows that after processing the first child, the next step is to append the parent's value. It doesn't need an extra flag because the "state" is encoded in the program's execution pointer.

In the iterative solution, our stack is just a simple data structure. It can store data (our nodes), but it cannot store a location in our code.

When we pop a node from the stack, we are always at the same spot: the top of the while loop. The loop has no memory of why this node is now at the top of the stack.

The loop needs to answer a critical question:

`"I just popped node. Is this the first time I am seeing it (and I should process its children), or am I returning to it after its children have been processed (and I should now add its value to the result)?"`


The visited flag is our manual bookmark to answer this question.

`visited = False`: This tells the loop, "This is the first time. Don't add my value yet. Instead, put my children and myself back on the stack in the correct order, but when you put me back, mark my bookmark as True."


`visited = True`: This tells the loop, "You are back at a bookmark. The prerequisites are complete. It is now time to add my value to the result."