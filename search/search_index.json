{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to patibanb.me</p>"},{"location":"About/","title":"Index","text":"<p>Hello! I'm P. Bhanuprasad , an Engineer with 10 years of experience building robust data pipelines, scalable analytics platforms, and cloud-based solutions. My expertise spans across data engineering, ETL development, big data technologies, and cloud infrastructure.</p> <p>Over the past decade, I have worked with diverse teams to design and implement end-to-end data solutions, optimize data workflows, and enable data-driven decision making. I am passionate about leveraging technology to solve complex business problems and deliver actionable insights.</p> <p>I enjoy collaborating with cross-functional teams, building useful things, solving pesky problems and staying up-to-date with the latest advancements in data engineering, analytics and AI.</p> <p>Feel free to connect with me on LinkedIn or explore this website!</p>"},{"location":"Algorithms/","title":"Algorithms","text":"<p>These are my notes on Algorithms. This is very much a work in progress. My plan is to put down everything in a rough way first, and keep refining it over time.</p>"},{"location":"Algorithms/#philosophy","title":"Philosophy","text":"<p>Broadly, I classify any algorithm or data structure into recursive or iterative. Of course, this is not a strict demarcation, but only in terms of the usual implementations or concpetualization.</p> <p>As for data structures, there are two fundamental types in terms of how they are stored : contiguous storage (arrays, dynamic arrays) and linked storage (linked lists, trees, graphs) </p>"},{"location":"Algorithms/#mental-models","title":"Mental models","text":"<p>To effectively use a concept, it helps greatly to have the right mental model which allows you to use it in a consistent manner.</p> <p>For example, understanding and thinking of binary search in terms of bisect left and bisect right makes it easy to actually use it in a consistent manner.</p> <p>Another example, for array partitioning, just thinking of and  defining the loop invariant correctly is key. </p> <p>My effort is always to develop the correct understanding and mental model for any concept.</p>"},{"location":"Algorithms/#call-a-thing-by-its-right-name","title":"Call a thing by its right name","text":"<p>Just knowing the name of a thing is very powerful.  Know the name of the problem and know the name of the algorithm.</p>"},{"location":"Algorithms/External_Sorting/","title":"External Sorting","text":""},{"location":"Algorithms/External_Sorting/#problem-definition","title":"Problem Definition","text":"<p>Given limited RAM, how do you sort a file that is too large to fit into memory?</p>"},{"location":"Algorithms/External_Sorting/#solution","title":"Solution","text":"<p>Suppose you have an X GB file and only 2 GB of RAM, where X &gt; 2.</p> <p>Steps:</p> <ol> <li>Divide the file into chunks of size equal to available RAM (e.g., X // 2 GB chunks if RAM is 2 GB).</li> <li>For each chunk:<ul> <li>Read the chunk into memory.</li> <li>Sort it.</li> <li>Write it back to disk as a \"part file\".</li> </ul> </li> <li>Merge the sorted part files:<ul> <li>This is now a k-way merge problem.</li> <li>You can either:<ul> <li>Run a single k-way merge, or</li> <li>Use multiple passes of two-way merges to ultimately merge all part files into a single sorted file.</li> </ul> </li> </ul> </li> </ol>"},{"location":"Algorithms/External_Sorting/#additional-references","title":"Additional References","text":"<ol> <li>Wikipedia: External Sorting</li> </ol>"},{"location":"Algorithms/properties_of_comparison_based_sorting_algorithms/","title":"Properties of Comparison-Based Sorting Algorithms","text":""},{"location":"Algorithms/properties_of_comparison_based_sorting_algorithms/#quicksort","title":"Quicksort","text":"<ul> <li>Stability: Not stable  </li> <li>Adaptivity: Not adaptive  </li> <li>In-Place: Yes  </li> <li>Time Complexity: O(N log N) average case  </li> <li>Worst Case: O(N\u00b2) (e.g., sorted input, duplicate keys, poor pivot selection)  </li> </ul> <p>Notes: - Pivot selection and partitioning schemes significantly affect complexity.</p> <p>Pivot Selection: </p> <ul> <li>Fixed at high or low index (worst case)</li> <li>Random (good enough in practice)</li> <li>Median-of-three, etc.</li> </ul> <p>Partitioning: </p> <ul> <li>Two-way (e.g., Hoare partitioning with weak condition)</li> <li>Three-way (e.g., Dijkstra)</li> <li>Dual-pivot partitioning</li> </ul> <p>Quicksort is a highly researched algorithm with many variations and derivatives\u2014it's more like a family of algorithms.</p> <p>Important: </p> <ul> <li>The most common partitioning scheme found online (Lomuto partition) performs more swaps than Hoare partition with a weak condition.</li> <li>Lomuto degrades to O(N\u00b2) when all elements are the same.</li> <li>Hoare partition with a strict condition also degrades to O(N\u00b2) for duplicate keys.</li> <li>Lomuto was popularized by Bentley in \"Programming Pearls\" because he found Hoare unintuitive.  </li> <li>Advantage: Lomuto uses two forward iterators, so it can be used on singly linked lists.</li> </ul>"},{"location":"Algorithms/properties_of_comparison_based_sorting_algorithms/#mergesort","title":"Mergesort","text":"<ul> <li>Stability: Stable  </li> <li>Adaptivity: Not adaptive  </li> <li>In-Place: No (needs extra space)  </li> <li>Time Complexity: O(N log N) worst case  </li> </ul> <p>Can be combined with insertion sort for small subproblem sizes.</p>"},{"location":"Algorithms/properties_of_comparison_based_sorting_algorithms/#bubble-sort","title":"Bubble Sort","text":"<ul> <li>Stability: Stable  </li> <li>Adaptivity: Can be made adaptive (add a flag to check if a swap occurred; if not, exit early)  </li> <li>In-Place: Yes  </li> <li>Time Complexity: O(N\u00b2)  </li> </ul> <p>Optimized Bubble Sort Example:</p> <pre><code>def optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        swapped = False  # Flag for no swaps in a pass\n        for j in range(n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True  # Swap occurred\n        if not swapped:\n            return  # Already sorted, no more passes needed\n    return arr\n</code></pre>"},{"location":"Algorithms/properties_of_comparison_based_sorting_algorithms/#insertion-sort","title":"Insertion Sort","text":"<ul> <li>Stability: Stable  </li> <li>Adaptivity: Adaptive  </li> <li>In-Place: Yes  </li> <li>Time Complexity: O(N\u00b2)  </li> </ul> <p>Example:</p> <pre><code>def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j &gt;= 0 and key &lt; arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n</code></pre> <ul> <li>Similar to optimized bubble sort, except:</li> <li>In bubble sort, the maximum element is bubbled into the unsorted section.</li> <li>In insertion sort, the minimum element is inserted into the sorted section.</li> <li>Online: Each new element can be put in its sorted place as it is received.</li> <li>Shell Sort: A faster variation of insertion sort (named after D.L. Shell), using insertion sort on periodic subarrays.</li> </ul> <p>See also: - Stack Overflow: Online vs Offline Sorting Algorithms - CS StackExchange: Fastest Online Sorting Algorithm</p>"},{"location":"Algorithms/properties_of_comparison_based_sorting_algorithms/#selection-sort","title":"Selection Sort","text":"<ul> <li>Stability: Not stable  </li> <li>Adaptivity: Not adaptive  </li> <li>In-Place: Yes  </li> <li>Time Complexity: O(N\u00b2)  </li> </ul> <p>Note: - Only advantage over insertion sort: performs fewer swaps.</p>"},{"location":"Algorithms/properties_of_comparison_based_sorting_algorithms/#additional-resources","title":"Additional Resources","text":"<ol> <li>Toptal: Sorting Algorithms</li> <li>YouTube: Sorting Algorithms Playlist</li> </ol>"},{"location":"Algorithms/Array_Partitioning/Djikstra/","title":"Djikstra's Three Way Partition","text":"<p>Coming Soon</p>"},{"location":"Algorithms/Array_Partitioning/Hoare/","title":"Hoare Partition","text":""},{"location":"Algorithms/Array_Partitioning/Hoare/#hoare-partition-with-strict-condition","title":"Hoare partition with strict condition","text":"<p>Let us consider the simplest version of the problem.</p> <p>Given an array of integers, rearrange the elements such that the left part contains elements less than or equal to a pivot value and the right part contains values greater than the pivot value.</p> <p>Consider this example array and a pivot value of 4   :</p> <p>Example</p> <p>[ 1 , 9, 3, 5, 7, 4, 8  ]</p> <p>If this array were already partitioned s.t. the left partition has only elements less than or equal to the pivot. These would hold true : <pre><code>Any element in left partition &lt;= pivot\nAny element in right partition &gt; pivot\n</code></pre> If we take left and right pointers  while verifying that arr[left] &lt;= pivot and arr[right] &gt; pivot, left and right pointers would move past each other before evaluating to False for the first time. Left pointer would end up at the BEGINNING of the right partition and the right pointer would end up at the END of the left partition.</p> <p>Pointers</p> <pre><code>[ 1,   3,     4,   5,   7,   8,   9 ]\n  L/T  L/T   L/T *L/F*                            # L = Left pointer, T = arr[left]&lt;= pivot is True , F = Its False\n            *R/F* R/T   R/T     R/T    R/T        # R = right pointer, T = arr[right] &gt; pivot is True, F = Its False   \n</code></pre> <p>If left evaluates to True while its less than right, it would mean that this element is in the wrong partition. This also implies that there must be an element in the right partition which belongs to the left partition. </p> <p>Pointers</p> <pre><code>[  1 ,   9,   3,   5,   7,   4,   8  ]         \n  L/T **L/F**                                    # L = Left pointer, T = arr[left]&lt;= pivot is True, F = Its False\n                          **R/F**   R/T          # R = right pointer, T = arr[right] &gt; pivot is True, F = Its False                \n</code></pre> <p>We can simply swap these and keep moving until left and right pass each other.</p> <p>So, the algorithm would be:</p> <p>Algorithm</p> <pre><code>#Initialize pivot = arr[0]\n\n#Invariant 1) [0,right] only contains elements less than or equal to pivot\n#Invariant 2) (right, len(arr) -1] only contains elements greater than pivot\n\n\nWhile left &lt;= right :\n      while left&lt;=right and (Invaraint 1) is True :\n           left +=1\n      while left&lt;=right and (Invariant 2) is True :\n           right -=1\n      if left &lt; right :\n          swap left and right\nreturn right\n</code></pre> <p>This implementation does not necessarily place the pivot in its sorted position.</p> <p>Or rather, the problem is not asking us to do this,</p> <p>This array is partitioned by 4 but 4 is not in its sorted position.</p> <p>Example</p> <pre><code>[ 1,   4,    3,  |5,   7,   8,   9 ]\n</code></pre> <p>We can put the pivot in its sorted position by swapping it with the right pointer after running the algorithm.  A good way to handle this is :</p> <ul> <li>Ensure that  the pivot at the lowest index.</li> <li>Run the partitioning algorithm on the rest of the array.</li> <li>Swap right with low.</li> </ul> <p>But again, this will not group multiple instances of pivot together if pivot is duplicated. That is another problem called three way partitioning.</p> <p>Here is the python implementation for both cases :</p> Code Without placing pivot in sorted postitionPlacing Pivot in its sorted position <pre><code>from typing import List\n\n#Given a list return partition index after partition on the pivot index value\ndef partition(nums: List[int],lo,hi) -&gt; int :\n    \"\"\"\n    Hoare partition with strong condition.\n    Picks the first element as the pivot value.\n    There is no guarantee that pivot will be in its right place in this implementation.\n    All we get is that the first half has elements less than or equal to pivot.\n    Pivot can be any value in the array. (Pivot Value can actually be any arbitrary value in this version).\n    \"\"\"\n    pivot = nums[lo]\n    left,right = lo+1 ,hi\n\n    while left &lt;= right :\n        while left&lt;= right and nums[left] &lt;=  pivot :\n            left+=1\n        while left &lt;=right and nums[right] &gt; pivot :\n            right-=1\n        if left &lt; right :\n            nums[left],nums[right] = nums[right],nums[left]\n\n    print(f\"Pivot Value: {pivot} , Partitioned list : {nums}, Partition Index = {right}\")\n    return right\n\nif __name__ == \"__main__\" :\n    nums = [2,4,5,1,4,8,9]\n    partition(nums, 0, len(nums)-1)\n    nums = [2,2,2,2,2,2]\n    partition(nums, 0, len(nums)-1)\n</code></pre> <pre><code>from typing import List\nimport random\n\n# Given a list return partition index after partition on the pivot index value\ndef partition(nums: List[int],lo,hi) -&gt; int :\n    \"\"\"\n    Hoare partition with strong condition.\n    Here we modififed the code slightly to:\n    Fix pivot value at index zero.\n    Partition by the pivot value.\n    Finally place the pivot  at the end of the left partition.\n    This implementation puts pivot in the sorted position as well after partitioning.\n    This version is  not entropy optimal . That is, it does not lead to balanced partitions when there are a lot of duplicates. \n\n    Why? Consider,  if this partition scheme is used in quickselect for finding the smallest element in an array of size n). \n    What happens when all elements are duplicates (disregarding random pivot selection):\n    [1,1,1,1,1,1]\n     l         r   Iter 1 : 6  comparisons\n     l       r     Iter 2 : 5  comparisons\n     l     r       Iter 3 : 4  comparisons\n     l   r         Iter 4 : 3  comparisons\n     l r           Iter 5 : 2  comparisons\n     lr            Iter 6 : 1  comparisons\n\n    Number of comparisons = SUM([1.....n]) = n(n+1)/2 = (n*2 + n ) /2\n    Therefore, Complexity is O(n^2) \n    \"\"\"\n\n    print(f\"Input List : {nums}\")\n    left, right = lo,hi\n\n    # RANDOM PIVOT SELECTION\n    # Always keep pivot at index lo\n    # pivot_index = random.randint(lo,hi)\n    # nums[lo],nums[pivot_index] =  nums[pivot_index],nums[lo]\n\n    #PARTITIONING\n    left+=1\n    pivot_val = nums[lo]\n\n    while left &lt;= right :\n\n        while left &lt;= right and nums[left] &lt;= pivot_val :\n            left+=1\n\n        while left &lt;= right and nums[right] &gt; pivot_val :\n            right-=1\n\n        if left &lt; right :\n            #swap\n            nums[left],nums[right] = nums[right],nums[left]\n\n    #Put pivot Value in sorted  position\n    nums[lo] , nums[right] =  nums[right] ,nums[lo]\n    print(f\"Pivot Value: {pivot_val}  ,Partitioned list : {nums}, Partition Index = {right}\")\n    return right\n\nif __name__ == \"__main__\" : \n    # nums= [1,2,3]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,2,2,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,4,5,1,4,8,9]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3]\n    # partition(nums, 0, len(nums)-1)\n    nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,-2,-5]\n    partition(nums, 0, len(nums)-1)\n</code></pre>"},{"location":"Algorithms/Array_Partitioning/Hoare/#hoare-partition-with-weak-condition","title":"Hoare partition with weak condition","text":"<p>The problem with the partition scheme with a strict condition (where we always put pivot values  in one of the partitions) is that it produces unbalanced partitions when used in quickselect or quicksort.</p> <p>Consider if the above partition scheme were used in quickselect for finding the smallest element in an array with k=0 and fixed pivot selection at arr[0]. </p> <p>What happens when all elements are duplicates :</p> <p>Dry Run</p> <p>l and r indicate the search space for each iteration of quickselect loop/each recursive call to quickselect. Comparisons refer to those made by the partitioning subroutine.</p> <pre><code>    [1,1,1,1,1,1]\n     l         r   Iter 1 : 5  comparisons\n     l       r     Iter 2 : 4  comparisons\n     l     r       Iter 3 : 3  comparisons\n     l   r         Iter 4 : 2  comparisons\n     l r           Iter 5 : 1  comparisons\n     lr            Iter 6 : 0  comparisons\n</code></pre> <p>The Hoare partition, after performing r-l+1 comparisons, would return the rightmost position for each call recursive call to quickselect. r would reduce linearly until it meets l, thus giving a quadratic running time!</p> <p>Number of comparisons = SUM([1.....n]) = n(n+1)/2 = (n*2 + n ) /2 Therefore, Complexity is O(n^2)  in this case.</p> <p>To mitigate this, we could slightly modify the definition of our partitions :</p> <p><pre><code>Any element in left partition &lt;= pivot\nAny element in right partition &gt;= pivot\n</code></pre> In terms of Invariants :</p> <p>Invariants</p> <pre><code>Invariant 1) [low,right] only contains elements less than OR EQUAL to pivot\n\nInvariant 2) (right, high] only contains elements greater OR EQUAL to pivot\n</code></pre> <p>That is, pivot values are allowed to be in either partition.</p> <p>Our problem now becomes : </p> <p>Reframed Problem</p> <p>Given an array of integers, rearrange the elements such that the left part contains elements less than or equal to a pivot value and the right part contains values greater than or equal to the pivot value.</p> <p>The implementation is tricky when handling values equal to pivot. We stop scanning when left or right are equal to pivot in either partition. We swap and move the left and right pointers. After any swap, both partitions will increase by 1. Pivot values might end up in any partition. This will also be the case when, left and right are both pointing to pivot value i.e. both partitions increase by 1 and there is a redundant swap between two pivot values.</p> <p>Algorithm</p> <pre><code>While left &lt;= right :\n      while  left&lt;=right and left &lt; pivot :\n           left +=1\n      while left&lt;=right and right &gt; pivot:\n           right -=1\n      if left &lt;= right :\n          swap left and right\n          left+=1\n          right-=1\nreturn right\n</code></pre> <p>Let us see the behavior of quickselect with this scheme for the same case :</p> <p>Dry Run</p> <pre><code>    [1,1,1,1,1,1]\n     l         r   Iter 1 : 5  comparisons\n     l   r         Iter 2 : 3  comparisons; This iteration returns r=0 and ends the loop\n     rl            Iter 2 END \n</code></pre> <p>Now the hoare partitioning subroutine will reduce r by half in each iteration. And quickselect is called LOG(n) times in the worst case, when k = 0. The complexity is reduced to LOG(n)*LOG(n).</p> <p>Here is the implementation :</p> Code Hoare Partition with Weak Condition <pre><code>from typing import List\nimport random\n\n\ndef partition(arr, lo, hi):\n    \"\"\"\n    Entropy Optimal Hoare partition.\n    Produces balanced partitions when there are large number of duplicates.\n    [lo,right] contains elements less than or equal to pivot.\n    (right,hi]  contains elements greater than or equal to pivot.\n    Invariants for the while loop :\n    [lo] has pivot  \n    [lo, left)  &lt;= pivot    #Has values &lt;= pivot\n    (right, hi] &gt;= pivot\n    [pivot|--- &lt;=pivot-----|-----Undetermined-------|---&gt;=pivot----]\n                            left               right\n    After execution of while loop : \n    [pivot|----&lt;=pivot------|-----&gt;=pivot------]\n    lo                  right                  hi\n    [lo,right] &lt;= pivot\n    After Putting pivot in sorted position : \n    [----&lt;=pivot----|pivot|-----&gt;=pivot------]\n    lo               right                  hi\n    Finally, return right.\n    \"\"\"\n    #PIVOT SELECTION\n    #Pick a random pivot index and always keep pivot at index lo\n    #NB:  random.randint(0,0) is 0.\n    pivot_index = random.randint(lo,hi)\n    arr[lo],arr[pivot_index] =  arr[pivot_index],arr[lo]\n    #read pivot value\n    pivot = arr[lo]\n\n    #PARTITIONING\n    #partition [lo+1,hi] ; \n    #NB : when lo == hi , while loop will not be executed\n    left,right = lo+1, hi\n    while left&lt;=right:\n        #Move left ahead if arr[left] is strictly less than pivot value\n        while left &lt;= right and arr[left] &lt; pivot :\n            left+=1\n        #Move right to the left if it is strictly higher than pivot\n        while left &lt;= right  and arr[right] &gt; pivot :\n            right-=1\n        #Swap left and right and move pointers\n        #If both values are equal to pivot this will do a swap,move pointers and effectively leave pivot values where they are. \n        if left &lt;=  right :\n            arr[left], arr[right] = arr[right], arr[left]\n            right-=1\n            left+=1\n    #Put pivot in sorted position\n    arr[lo], arr[right] = arr[right], arr[lo]\n    print(f\"Pivot Value: {pivot}  ,Partitioned list : {arr}, Partition Index = {right}\")\n    return right\n\nif __name__ == \"__main__\" : \n    # nums= [1,2,3]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,2,2,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,4,5,1,4,8,9]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3]\n    # partition(nums, 0, len(nums)-1)\n    nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,-2,-5]\n    partition(nums, 0, len(nums)-1)\n</code></pre>"},{"location":"Algorithms/Array_Partitioning/Hoare/#important-things-to-note","title":"Important things to Note:","text":"<ul> <li> <p>This algorithm is not stable. The relative order of elements will not be preserved. Naive partitioning using extra space is the only algorithm which preserves relative order of elements.</p> </li> <li> <p>When used in quicksort/quickselect, instead of fixed pivot selection either random pivot selection or selection algorithms like Median of Medians are used to pick the pivot.  </p> </li> </ul>"},{"location":"Algorithms/Array_Partitioning/Hoare/#additional-resources","title":"Additional Resources","text":"<ol> <li>ALGS4 - Sedgewick </li> </ol>"},{"location":"Algorithms/Array_Partitioning/Introduction/","title":"Introduction","text":"<p>Array partitioning is the problem of rearranging the elements of an array according to some predicate. </p> <p>We are interested here in array partitioning schemes usually applied in quicksort, particularly Hoare's and Lomuto's partitioning schemes. These are two way partitioning schemes, which is to say that they have a binary predicate which could place elements in either left or right partitions based on comparison with a pivot value. There are different ways of implementing two way paritioning based on how you define the predicate. We will see this in some depth while understanding Hoare Partitioning.</p> <p>If we instead define a ternary predicate which puts an element in one of three partitions : left , middle or right based on comparison with a pivot value, it is called three way partitioning. All the duplicates are grouped into a middle partition.  Three way partitioning is also called the Dutch National Flag Problem, because the flag has three color bands. There are again different algorithms for doing this, one of which is Djikstra's, who was the one to name this as the Dutch National Flag problem. On the same pattern, the two way partitioning problem is sometimes called the Polish National Flag problem, because that flag has two color bands.</p> <p>Tip</p> <p>Once you understand Partitioning you get two other Algorithms for free : Quicksort and Quickselect.</p> <p>Paritioning Schemes are the actual meat of the Quicksort (and Quickselect)  algorithms. What makes Quicksort so interesting is that it can be implemented in slightly different ways with very different performance characteritics using any of these partitioning schemes. This is why Quicksort is not really a single algorithm but a family of algorithms and is a research area by itself in Computer Science.</p>"},{"location":"Algorithms/Array_Partitioning/Lomuto/","title":"Lomuto Partition","text":""},{"location":"Algorithms/Array_Partitioning/Lomuto/#defining-the-problem","title":"Defining the problem","text":"<p>Let us consider the simplest case, that of an array of integers.</p> <p>Given an array of integers, rearrange the elements such that the left part contains elements less than or equal to a pivot value and the right part contains values greater than the pivot value.</p>"},{"location":"Algorithms/Array_Partitioning/Lomuto/#the-algorithm","title":"The Algorithm","text":"<p>The Lomuto partition fixes uses two forward iterators to maintains two invariants :</p> <p>[lo,s) contains only elements less than or equal to the pivot.  # Left closed Right open interval</p> <p>[s,f) contains elements larger than the pivot.      # Left closed right open interval</p> <p>Usually, pivot is fixed at hi. </p> <p>Initial conditions are :</p> <p>s, f = 0,0</p> <p>Both invariants are trivially true initially.</p> <p>During execution :</p> <p>Pointers</p> <pre><code>[---&lt;=pivot----|---&gt;pivot------|---Unexamined---|pivot] \nlo              s               f                    hi \n</code></pre> <p>s and f can be thought of as slow and fast pointers with s at the write position and f at the read position.</p> <p>The algorithm is </p> Code <pre><code>def partition(arr,lo,hi) :\n    s = lo\n    pivot = arr[hi]\n    for f in range(lo,hi+1) : \n         if arr[f] &lt;= pivot : \n              arr[s],arr[f] = arr[f],arr[s] #swap s and f\n              s+=1\n    return s-1      \n</code></pre> <p>Since [s,f] is a half closed interval, it is empty if  s and f are equal. If there is a gap, this interval is gauranteed to only contain elements greater than pivot, since a gap INCREASES as a result of f pointing to a value less than or equal to the pivot and s pointing to a value greater than pivot,  in the first place.</p> Dry Run <pre><code>General case :\n     [ 1,  4,  7,  3,  1,  4 ]\n0      sf                      # Initial condition, pivot = 4, arr[f] &lt;= 4 is True,  s will be swapped with f and both will move ahead\n1          sf                  # arr[f] &lt;= 4 , swap s with f and move both ahead\n2              sf              # arr[f] &lt;=4 is False, s stays where it is and only f moves ahead\n3              s  f            # arr[f] &lt;=4 is True, swap s with f and move both ahead\n4    [ 1,  4,  3,  7,  1,  4 ]\n                   s   f       # arr[f] &lt;=4 is True, swap s with f and move both ahead\n5    [ 1,  4,  3,  1,  7,  4 ] # arr[f] &lt;=4 is True, swap s with f and move both ahead\n                       s   f\n6    [ 1,  4,  3,  1,  4,  7 ] # arr[f] &lt;=4 is True, swap s with f and move both ahead\n                           s   # For loop ends\nReturn s -1\n\nOnly one element :\n  [4]\n0  sf      #arr[f] &lt;= f is True, swap s with f and move both ahead\n1    sf\nReturn s-1\n\nSorted array \n  [1,2,3]\n0  sf           \n1    sf\n2      sf\n3        s\n\nreturn s-1\n\nReverse sorted array :\n  [ 3, 2, 1 ]\n0   sf               #Initial conditions, arr[s] &lt;= 1 is False, only f will move ahead\n1   s  f             #arr[s] &lt;= 1 is False, only f will move ahead          \n2   s     f          #arr[s] &lt;= 1 is True, s and f will be swapped and both will move ahead \n3 [ 1, 2, 3 ]\n       s     f       #for loop ends\nreturn s -1 \n\nReverse sorted array with duplicate keys:\n[3, 2 ,1, 1]\n s     f\n[1, 2 ,3, 1]\n    s     f\n[1, 1 ,3, 2]\n       s     f   # for loop ends, \nreturn s-1 \n\nDuplicate keys :\n[1 , 1, 1, 1]\n             sf\nreturn s-1\n</code></pre>"},{"location":"Algorithms/Array_Partitioning/Lomuto/#variant-implementation","title":"Variant Implementation","text":"<p>We could redefine our problem statement slightly : Given an array of integers, rearrange the elements such that the left part contains elements less  a pivot value and the right part contains values greater than or equal to the pivot value.</p> <p>[lo,s) only contains elements strictly less than pivot [s,f)  contains elements equal to or greater than pivot.</p> <p>Initial conditions are :</p> <p>s, f = 0,0</p> <p>Both invariants are trivially true initially.</p> <p>During execution :</p> <p>Pointers</p> <pre><code>[---&lt;pivot----|---&gt;=pivot------|---Unexamined---|pivot] \nlo             s                f                    hi \n</code></pre> <p>The algorithm is </p> Code <pre><code>def partition(arr,lo,hi) :\n    s = lo\n    pivot = arr[hi]\n    # The range might as well be range(lo,hi+1). It would make no difference except one extra redundant comparsion.\n    for f in range(lo,hi) : \n         if arr[f] &lt; pivot : \n              arr[s],arr[f] = arr[f],arr[s] #swap s and f\n              s+=1\n    arr[s],arr[hi] = arr[hi],arr[s]\n    return s      \n</code></pre> <p>When for loop exits, s is positioned at the sorted position of pivot. We swap pivot with s and return s.</p> Dry Run <pre><code>[ 1,  4,  7,  3,  1,  4 ]\n      s       f             # arr[f] &lt; pivot is True, s and f will be swapped and both will move ahead.\n[ 1,  3,  7,  4,  1,  4 ]    \n          s       f\n[ 1,  3,  1,  4,  7,  4 ]\n              s       f\n[ 1,  3,  1,  4,  7,  4 ]\n                  s       f  # for loop ends\n[ 1,  3,  1,  4,  4,  7 ]\n                  s       f  # FInally Swap s with f\nReturn s \n\n\nReverse sorted array :\n  [ 3, 2, 1 ]\n    s        f \n  [ 1, 2, 3 ]\n    s        f\nreturn s\n\nReverse sorted array with duplicate keys:\n[3, 2 ,1, 1]\n s          f\nreturn s \n\nDuplicate keys :\n1  1  1  1 \ns          f #swap s[0] with s[-1]\nreturn s \n</code></pre> <p>Remember</p> <p>The two implementations behave differently when it comes to duplicate keys :</p> <p>The first implementation puts one instance of the pivot value in the LAST sorted position. The second implementation puts one instance of the pivot value in the FIRST sorted position.</p>"},{"location":"Algorithms/Array_Partitioning/Lomuto/#important-things-to-note","title":"Important things to note.","text":"<p>Tip</p> <p>With quickselect or quicksort, using Hoare partition with a weak condition is preferable to Lomuto.</p> <p>Lomuto partition has the same problem as Hoare partition with a strict condition when it somes to duplicate keys. It degenrates to O(n^2). Also, performs more swaps.</p> <p>Tip</p> <p>Lomuto is semi-stable. Some 'easy' interview style problems can be solved only if you know Lomuto and this property of the algorithm.</p> <p>Also, since it uses two forward iterators, it can be applied to singly linked lists.</p>"},{"location":"Algorithms/Array_Partitioning/Lomuto/#additional-resources","title":"Additional Resources","text":"<ol> <li>Sorting Lecture Notes</li> <li>Lomuto Partition Scheme</li> <li>Partition Notes by Stepanov</li> <li>Lomuto's Comeback</li> <li>Array Partition Blog</li> <li>Quick Sort Notes</li> </ol>"},{"location":"Algorithms/Binary_search/Introduction/","title":"Introduction","text":"<p>Note</p> <p>This article is heavily based on this awesome video by mcoding. This is perhaps the best resource on the internet to understand binary search.</p>"},{"location":"Algorithms/Binary_search/Introduction/#bisect-left","title":"Bisect Left","text":"<p>Binary search (also called bisection search) is an algorithm to find an element quickly in a sorted array.</p> <p>Example</p> <p>Suppose we are trying to find 7 in this array : <code>[2,3,3,4,6,7,8,9]</code></p> <ol> <li> <p>Is the element you want to find in the left half or the right half? \u2192 Right half</p> <p>Our search space is now only the right half.  <pre><code>[        6,7,8,9 ] # remaining 4\n</code></pre> 2. Repeat the process <pre><code>[        6,7     ] # remaining 2\n[          7     ] # remaining 1\n</code></pre> 3. Finally there is just one element left. That's our element.</p> </li> </ol> <p>At each step you cut out half of the search space. How can the idea be so simple, but the implementation be so difficult?. It's not - you just have to think about it in the right way.</p> <p>The First Decision: What Do You Want to Return? The object itself, or the index where it is at?</p> <ul> <li>The index itself is a \"more useful piece of information\". You can always just grab the object at that index later.</li> </ul> <p>What do we do when the object we are looking for is not there?</p> <ul> <li>Return -1? Raise exception? </li> <li>What if there are multiple valid indices to choose from? </li> </ul> <p>With every arbitrary choice we make, we would have to remember the implementation details for each choice.</p> <p>Implementation Complexity</p> <p>A better way to do it, is to rephrase the question, so that there is always exactly one answer.If I were going to add another element to the array, say 7, where should I put it so that it is the first 7?</p> <ul> <li>If there are no 7s in the array, this answer would be the index where you would put 7 to maintain the sorted property of the array. </li> <li>If there is at least one 7, the answer would be the index of the first 7.</li> <li>The index would be zero if the array is empty, which is not actually a valid index, but is the right answer to our Question!</li> <li>It could also be <code>(n-1) + 1</code> if the element is absent from the array and greater than all elements in a non-empty array. This is also not a valid index. But, again,it is the right answer to our Question.</li> </ul> <p>Correct Implementation Strategy</p> <p>The array being sorted is not actually the property being used in binary search. The property is that everything greater than 7 is to the right of 7 and everything less than 7 is to the left of 7.</p> <p>Here, I disturbed the order of some elements in a sorted array: <code>[2, 3, 5, 4, 6, 7, 9, 8]</code></p> <p>The array is no longer in sorted order, but notice the steps are exactly the same. What we need is that everything less than 7 is to the left of 7 and everything greater than 7 should be to the right. </p> <p>Important Insight</p> <p>In fact, the numbers can be replaced with the important information: Is this number less than 7?</p> <p>Pointers</p> <pre><code>[2, 3, 5, 4, 6, 7, 9, 8]\n T  T  T  T  T  F  F  F  #&lt;7?\n</code></pre> <p>Notice how any Trues are on the left and any Falses are on the right.</p> <p>Now that we are looking at the relevant data, where do we insert 7 so that it is the first 7?</p> <p>Notice that the answer we are looking for is the index of the first False value or the end of the array if there are no false values. This is the key insight, we need to keep in mind that makes the implementation extremely easy to remember :</p> <p>Tip</p> <p>Squint Your Eyes and Find the First False Value</p> <p>Ok, let's write the implementation:</p> <p>Bisect Left</p> <pre><code>def bisect(arr, x):\n    lo = 0\n    hi = len(arr)     \n    while lo &lt; hi:\n        mid = (lo + hi) // 2\n        if arr[mid] &lt; x:  # mid is a True value\n            lo = mid + 1\n        else:            # mid is a False Value\n            hi = mid\n    return lo\n</code></pre> <p>The first two lines inside the function, initialize lo and hi.</p> <p>Tip</p> <p>lo and hi are lower and upper bounds on where this First FALSE index is. </p> <p>If our answer is zero, it would mean that first value is False or array is empty. If it is len(arr), it would mean that all the values are True and we would have to put the new element at the end of the array.</p> <p>The idea of the while loop (line 4), is that we continuously decrease the upper bound and increase the upper bound until they are equal. lo and hi will meet at the unique index we are looking for. So, we could return lo or high, once the while loop runs, it would make no difference.</p> <p>Next, we calculate the midpoint in each iteration of the while loop. Python can represent arbitrarily large integers, so you do not have to worry about overflow. But, if you were using another language, you might have to worry about overflow. In that case, you would represent mid as <code>lo+(hi-lo)//2</code> : lo plus half the distance between hi and lo. If you do it this way, it will never overflow.</p> <p>Comparing mid with x</p> <p>Next comes the part which is often written incorrectly. We must compare whatever is at mid with our search term <code>x</code>. Remember, we are looking for the first False value where True of False is determined by the question : Is this element strictly Less than <code>x</code>:  <pre><code>if arr[mid] &lt; x :\n    lo = mid+1   # mid is a True Value\nelse :\n    hi =mid      # mid is a False Value\n</code></pre> If <code>mid</code> is strictly less than <code>x</code>, it is a <code>True</code> Value. Since the Value at <code>mid</code> is <code>True</code>, the earliest a <code>False</code> Value could occur is the next index which is <code>mid+1</code>. Therefore, our lower bound becomes <code>mid+1</code></p> <p>What if <code>mid</code> is a <code>False</code> Value? In this case the FIRST <code>False</code> Value could not be any later than mid. But it could be mid or earlier than mid. There could be other <code>False</code> values before midm. So our upper bound becomes mid.</p> <p>When the while loop is done, lo and hi meet at the index we are looking for.</p> <p>How do we know that this implementation always gives the right answer?  - We know that lo is always &lt;=  answer  - We also know that answer is always &lt;= hi  - In each iteration the difference between hi and lo always decreases by at least one.</p> <p>Thereifre, lo and hi always meet at the answer.</p> <p>But how do we know that in each iteration lo and hi come closer to each other by at least one? If we enter the True clause on line no. 6 <code>lo = mid+1</code> ensures that lo always increases by at least one.</p> <p>If we enter the False clause on lines 8,9 we are setting hi to mid. So, hopefully we are lowering hi. But how do we know mid is actually strictly less than hi?</p> <p>Here we are actually using the property that integer division rounds down. Inside the while loop: while lo &lt; hi, lo is strictly less than hi. So lo + hi is strictly less than hi + hi.</p> <p>That means for calculating mid: mid = (lo + hi) // 2</p> <p>When we divide (lo + hi) by 2 and round down we will get something strictly less than (hi + hi) // 2 i.e. hi.</p>"},{"location":"Algorithms/Binary_search/Introduction/#checking-the-return-value-of-bisect-left","title":"Checking the return value of Bisect Left","text":"<p>Since bisect left can return an out of bounds index and not necessarily the index of a matching value, you have to handle this when using it, depending on what you are trying to do.  </p> <p>Checking if x exists using bisect left</p> <pre><code>def search(arr:list, x) -&gt;int :\n    idx = bisect_left(arr,x)\n    if i != len(arr) and arr[i] == x:\n        return i\n    raise ValueError(f\"{x} not found!\")\n</code></pre>"},{"location":"Algorithms/Binary_search/Introduction/#bisect-right","title":"Bisect Right","text":"<p>But wait. Your ask: instead of returning a 7 so that it is the first seven, could I not return the index, so that it would be the last 7?</p> <p>You could. You could follow the same analysis and get a very similar algorithm.</p> <p>To find where it should go to be the first 7, the relevant piece of information is: \"Is this (current element) strictly less than 7\"</p> <p>To find where it should go to be the last element, the relevant piece of information i: \"Is this (current element) less than or equal to  7\"</p> <p>Bisect Left vs Bisect Right</p> <pre><code>[2, 3, 5, 4, 6, 7, 7, 7, 8, 9]\n[T, T, T, T, T, F, F, F, F, F] #&lt;7  ; Bisect Left\n[T, T, T, T, T, T, T, T, F, F] #&lt;=7 ; Bisect Right\n</code></pre> <p>In either case, you are looking for the first False value. You just need to decide what you mean by True or False.</p> <p>Bisect Right</p> <pre><code>def bisect_right(arr, x):\n    lo = 0\n    hi = len(arr)     \n    while lo &lt; hi:\n        mid = (lo + hi) // 2\n        if arr[mid] &lt;= x:  # mid is a True value\n            lo = mid + 1\n        else:            # mid is a False Value\n            hi = mid\n    return lo\n</code></pre>"},{"location":"Algorithms/Binary_search/Introduction/#checking-the-return-value-of-bisect-right","title":"Checking the return value of Bisect Right","text":"<p>Bisect right can return values from 0 to len(arr). If it returns zero it means that either arr is empty or all elements in the array are greater than x. Any other value could mean x exists at i-1. A return value of len(arr) means x is greater than or equal to all elements in the array.</p> <p>Checking if x exists using bisect right</p> <pre><code>def search(arr:list, x) -&gt;int :\n    idx = bisect_right(arr,x)\n    if i &gt; 0 and arr[i-1] == x:\n        return i\n    raise ValueError(f\"{x} not found!\")\n</code></pre>"},{"location":"Algorithms/Binary_search/Introduction/#summary","title":"Summary","text":"<p>Key Takeaways</p> <ul> <li>Binary search is fundamentally about finding boundaries in bisected data</li> <li>Reframe the problem as \"find the first False value\" </li> <li>The difference between <code>bisect_left</code> and <code>bisect_right</code> is just changing <code>&lt;</code> to <code>\u2264</code></li> <li>Always think about what \"True\" and \"False\" mean in your specific context</li> </ul>"},{"location":"Algorithms/Binary_search/Median_of_two_sorted_arrays/","title":"Median of two sorted arrays","text":"<p>This is one of those problems which I like to call an \"Algorithm in itself\". Although categorized under Binary Search, its not just a straightforward application of it.</p> <p>Description</p> <p>Leetcode Link </p> <pre><code>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 &lt;= m &lt;= 1000\n0 &lt;= n &lt;= 1000\n1 &lt;= m + n &lt;= 2000\n-106 &lt;= nums1[i], nums2[i] &lt;= 106\n</code></pre> <p>Let us figure out how binary search can be applied to solve this problem..</p>"},{"location":"Algorithms/Binary_search/Median_of_two_sorted_arrays/#what-is-the-data","title":"What is the data?","text":"<p>nums1 = [1,2], nums2 = [3,4]</p> <p>Two sorted arrays.</p>"},{"location":"Algorithms/Binary_search/Median_of_two_sorted_arrays/#what-is-being-asked","title":"What is being asked?","text":"<p>To find the median in logarithmic time.</p>"},{"location":"Algorithms/Binary_search/Median_of_two_sorted_arrays/#thoughts","title":"Thoughts","text":"<p>What is a median</p> <p>Consider : <pre><code>[1 2 |3 4]  #right partition is inclusive \n</code></pre> If we partition an even lengthed sorted array such that the left and right partitions are of equal size.</p> <p>The median is ( max(left partition) + min(right partition)  ) / 2</p> <p>If the array is odd lengthed : <pre><code>[1 2 3 4 5]\n     *\n</code></pre> We can consider the middle element to belong to both partitions. In which case <pre><code>[1 2 3 4 5]\n     *\n</code></pre></p> <p>The middle element IS the median i.e. index len(arr)//2</p> <p>Provided A and B are both sorted, We can always find partitions on A and B such that elements to the left of both partitions are less than elements to their right and both partitions combined divide the combined arrays in half. It will be clear what is meant from the examples below (Consider left out of bounds position to be -inf and right out of bounds position to be +inf). </p> <p>Example 1 : Valid Partitions</p> <pre><code>Example 1: \nB [ 1, 2, |6, 7]  # right pertition is inclusive\nA  [  5, |10  ]\n\n1,2,5  &lt; 6,7,10\n</code></pre> <p>Example 2 : Valid Partitions</p> <pre><code>Example 2 :\nB [ |5, 6, 7, 8, 9 ] # consider left out of bounds position to be -inf and right out of bounds position to be +inf\n\nA [ 1, 2, 3, 4| ]\n\n1,2,3,4 &lt; 5,6,7,8,9\n</code></pre> <p>Note that if you pick a partition on array A, there is only one corresponding partition on array B because we are looking for the set of partitions which divide the combined arrays in two halves.</p> <p>We can tell a set of partitions COULD BE a valid by verifying that the last element of the left partition of one array is less than or equal to the first element of the other arrays right partition. We can check the inverse to confirm that the partitions are in fact not valid. </p> <p>We can in fact use binary search to find the correct partitions. All we need is to know which way should we move one of the partitions. We will go into this in more detail. </p> <p>The idea is if we find the correct partitions, we can calculate the median by looking at the elements clustered around both partitions. Let's see how..</p> <p>The first question is how should we define the partitions?</p> <p>partition_a + partition_b = (m+n+1) //2 OR partition_a + partition_b = (m+n) // 2 </p> <p>let len(A) =m and len(B) = n </p> <p>FOR ODD LENGTHED ARRAY :</p> <pre><code>B  [1]   ; #IFF partition_b = (m+n +1 )//2 - partition_a  = 2//2 -0 = 1 But *IFF partition_b =  (m+n)//2 - partition_a =  1//2 -0 = 0-0 = 0 \n   *0 #1  \nA  [ ]   ; partition_a = (0+ 0)//2 =0 \n    0\n</code></pre> <p>If we say that partition_x + partition_y = (m+n)//2 then median is in the right partition in case of odd lengthed array.</p> <p>If we say that partition_x + partition_y = (m+n+1)//2 then median is in the left partition in case of odd lenghted array.</p> <p>It makes no difference for arrays where m+n is even. <pre><code>B [1 2]   ; #IFF partition_b = (m+n+1)//2 - partition_a  = 5//2 - 1 = 2- 1 = 1 and *IFF partition_b = (m+n)//2 - partition_a = 4//2 -1 = 1\n    #*1\nA [1 2]   ; partition_a = (0 + 2) // 2 = 1\n</code></pre></p> <p>Lets pick one convention : </p> <p>partition_a + partition_b = (m+n) //2</p> <p>Now for the binary search:</p> <p>It makes sense to binary search on the smaller array. Lets call this array A and the partition on it,  partition_a.</p> <p>Binary Search Logic</p> <p>In each iteration of the binary search, we consider mid as partition_a. For each partition_a we determine partition_b (as per our definition) and ask is left_b &gt; partition_a where left_b is the last element in the left partition of array B. </p> <ul> <li>If this is TRUE, then partition_a cannot be the pivot. Now the question is where do we move partition_a: to the left or to the right? We know that left_b is too big right now, so it needs to be made SMALLER i.e. Moved left. For doing this, by definition of our partitions, we NEED TO MOVE partition_a to the right i.e. partition_a need to be made larger. This is like increasing our lower bound.</li> <li>If this is FALSE, it means that the current set of partitions COULD BE VALID. Therefore, we set hi = mid. That is, decrease our upper bound.</li> </ul> <p>Dry Run</p> <pre><code>INIT:         \nB [ 1  3  4  5   6  ]\nA  [ 2  6  7   8   ] \n     lo          hi\n\nITER 1:\nA [1  3  4  5  6  ]\n         *            #left_b is 3.\nB  [ 2 6  7  8 ]  \n     lo   *            #3 &gt; 7 is F; this could be the right partition_a ; hi = mid\n         F/hi\n\nITER 2 :\nA [1  3  4  5  6  ]\n            *\nB  [ 2  6 7  8 ]\n   lo   *           #4&gt; 6 is F  ; this could be partition_a hi = mid            \n       F/hi\n\nITER 3 :\nA [1  3  4  5  6  ]\n               *\nB  [ 2    6  7  8 ]\n     *              #5&gt;2 T; This cannot be the right partition_a ;\n     T/lo hi        #lo = mid+1  ; Now lo == hi; lo and hi have converged and  loop exits in next iteration\n\nITER 5 :\nB [2   6   7   8]  # lo = hi = 1 and while loop exits\n       *\n       F/lo,hi\n</code></pre> <p>tl;dr</p> <p>Binary search will converge on the first false value. <pre><code>   [1    3    4     |5    6  ]\n     [2     |6    7    8]\n      T     F    F    F\n</code></pre></p> <p>In our binary search we need a function move_right which simply returns left_b &gt; right_a</p> <p>Thats it. Once , we have the right partition, calculate median:</p> <ul> <li> <p>If (m+n) is odd : return min(right_a, right_b)</p> </li> <li> <p>If (m+n) is even : return (max(left_a, left_b) + min(right_a, right_b)) /2 </p> </li> </ul>"},{"location":"Algorithms/Binary_search/Median_of_two_sorted_arrays/#code","title":"Code","text":"Code <pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:\n        # A is always the smaller array\n        A, B = nums1, nums2 \n        if len(A) &gt; len(B) :\n            A , B = B, A\n\n        #measure their lengths    \n        m,n = len(A), len(B)\n\n        def find_partition_b(partition_a) : \n            return (m+n)//2 - partition_a\n\n        def get_left(partition,array) :\n            return float('-inf') if (partition-1 )&lt;0 else array[partition-1]\n\n        def get_right(partition,array) :\n            return float('inf') if (partition)&gt;= len(array) else array[partition]\n\n        def move_right(partition_a) : \n            partition_b = find_partition_b(partition_a)\n            left_b = get_left(partition_b,B)\n            right_a = get_right(partition_a,A)\n            return left_b &gt; right_a\n\n        #binary search to find the correct partition_a\n        lo, hi  = 0 , len(A)\n        while lo &lt; hi :\n            partition_a = (lo +hi) // 2\n            if move_right(partition_a) :\n                lo = partition_a+1\n            else :\n                hi = partition_a\n\n        #lo and hi have converged on the correct partition_a \n        partition_a,partition_b   = lo, find_partition_b(lo)\n        right_a = get_right(partition_a,A)\n        right_b = get_right(partition_b,B)\n\n        #combined array length is odd\n        if (m+n) % 2 == 1 :\n            return min(right_a,right_b)\n\n        #combined array length is even    \n        left_a = get_left(partition_a,A)\n        left_b = get_left(partition_b,B)\n        return ( max(left_a,left_b) + min(right_a,right_b) ) / 2        \n</code></pre>"},{"location":"Algorithms/K_Way_Merge/","title":"The k-way Merge problem","text":""},{"location":"Algorithms/K_Way_Merge/#merging-k-sorted-arrays","title":"Merging k sorted arrays","text":"<p>We can think of the k-way merge problem as a generalization of the 2-way merge problem. That is given, k sorted containers, return a merged sorted container.</p> <p>In the 2-way merge problem , we had a binary choice when picking the next value to write to the merged container.  Now we have a k-way choice among k or less elements at each step. We basically need a good way to pick the smallest value from among all possible choices. This is what a heap does. Since we are considering containers sorted in a non decreasing order, a Min Heap is what we need to dynamically pick the smallest value at each step.</p> <p>The crux of the algorithm is :</p> <p>Algorithm</p> <pre><code>initialize a Min heap of all possible choices. \nWhile there is something in the heap : \n   Pop the heap top and write it to the merged container.\n   Get the element next to popped element in the container to which it belongs (If it exists). Put it in the heap.\n</code></pre> <p>Thats it.</p> <p>The code should actually simpler than handling the 2-way merge because there are no if else conditions to handle unequal lengthed arrays.</p> Code K Way Merge on Arrays <pre><code>\"\"\"\nThe same problem but with a different signature :\nhttps://www.geeksforgeeks.org/problems/merge-k-sorted-arrays/1\n\"\"\"\n#User function Template for python3\nfrom typing import List\nfrom heapq import heapify, heappop, heappush\nclass Solution:\n    #Function to merge k sorted arrays.\n    def mergeKArrays(self, arr : List[List[int]]) -&gt; List[int]:\n        \"\"\"\n        Given k sorted arrays, return a single merged array.\n        Input :\n         arr : a list of integer arrays\n        \"\"\"\n        # return merged list\n        len_res = 0\n\n        #Priority Queue- min heap\n        pq = []\n        #Assume that arrays can be of unequal length\n        #Initialize min heap\n        for array in arr :\n            len_res += len(array)\n            #Store the current index and a reference to the array for getting the next value in the array\n            pq.append((array[0] , 0 , array))\n\n        #heapify pq\n        heapify(pq)\n\n        #allocate result array\n        res = [None] * len_res\n\n        #write pointer\n        write_ptr = 0 \n        #Pick the lowest value from the current choices and write it to res\n        while pq :\n            curr_val, curr_ptr, curr_arr = heappop(pq)\n            res[write_ptr] = curr_val\n            if curr_ptr &lt; len(curr_arr) -1  : \n                heappush(pq, (curr_arr[curr_ptr+1] , curr_ptr+1,curr_arr ))\n            write_ptr+=1\n        return res\n\nif __name__ == \"__main__\" :\n    print( Solution().mergeKArrays([[1,2,3] , [5,6] , [9,9,10]]) )\n</code></pre>"},{"location":"Algorithms/K_Way_Merge/#merging-k-sorted-linked-lists","title":"Merging k sorted linked lists","text":"<p>The same thing for linked lists. </p> Code K Way Merge on Arrays <pre><code>from heapq import heapify,heappush,heappop\n#Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n        pq=[]\n        for idx, head in enumerate(lists) : \n            if not head : continue\n            #Put idx between the value and the node object  to avoid comparing objects in case of a tie \n            #Which will lead to this error :'&lt;' not supported between instances of 'ListNode' and 'ListNode'\n            heappush(pq,(head.val,idx, head)) \n\n        #Allocate Write container and write pointer\n        dummy = ListNode(0)\n        write_ptr = dummy\n\n        while pq :\n            #Pick the lowest valued node from available choices.\n            _,idx,curr_node = heappop(pq)\n\n            #write to write container and move write pointer ahead\n            write_ptr.next = curr_node\n            write_ptr = write_ptr.next\n\n            #For curr_node, put its next node in the heap  \n            nxt_node = curr_node.next \n            if nxt_node : heappush(pq,(nxt_node.val, idx, nxt_node ))\n        return dummy.next\n</code></pre>"},{"location":"Algorithms/Merge_Sort/","title":"Merge Sort","text":""},{"location":"Algorithms/Merge_Sort/#sorting-an-array","title":"Sorting an array","text":"<p>tl;dr</p> <p>Think of Merge Sort as a binary recursive application of 2-way merge where the left and right recursive calls sort the left and right subarrays and we merge the two halves in the post order position.  </p> <p>Thats it.</p> <p>The actual sorting is a result of the merge function applied in a bottom up fashion from smallest subarray lengths.The actual sorting is a result of the merge function applied in a bottom up fashion from smallest subarray lengths.</p> <p>As for the implementation details :</p> <p>Instead of passing arrays to the merge method, pass pointers. Three pointers are sufficient : lo , mid and hi. The subarrays to be merged are always adjacent: arr[lo...mid] and arr[mid+1...hi]</p> <p>Base case is hit when lo = hi . A subarray of size one cannot be divided an further and is sorted by definition.</p> <p>Merging cannot be done in place. So merge sort does require extra space. Instead of allocating extra temp space in each recursive call, just allocate extra space as external variable, equal to length of array. This temp space can be used to perform 2-way merge using the lo, mid and hi pointers passed to merge method. </p> Code Merge Sort on Array <pre><code>\"\"\"\nMerge Sort Solution for https://leetcode.com/problems/sort-an-array/description/\n\"\"\"\nclass Solution:\n    def merge(self, lo,mid,hi) :\n        \"\"\"\n        Merge self.nums[lo:mid+1] and self.nums[mid+1,hi+1] into self.temp[lo:hi+1] \n        Write back self.temp[lo:hi+1] into self.nums[lo:hi+1]\n        \"\"\"\n        print(\"merge \" ,lo,mid,hi)\n        for i in range(lo,hi+1) :\n            self.temp[i] = self.nums[i]\n\n        p1 = lo \n        p2 = mid+1\n        p3 = lo \n\n        while p1 &lt;= mid and p2 &lt;= hi :\n            if self.temp[p1] &lt; self.temp[p2] :\n                self.nums[p3] =  self.temp[p1]\n                p1+=1\n            else : \n                self.nums[p3] =  self.temp[p2]\n                p2+=1\n            p3+=1\n        while p1 &lt;= mid :\n            self.nums[p3] = self.temp[p1]\n            p1+=1\n            p3+=1\n\n        while p2 &lt;= hi :\n            self.nums[p3] = self.temp[p2]\n            p2+=1\n            p3+=1\n\n    def sort(self, lo,hi) :\n        \"\"\"\n        DRY RUN UNTIL FIRST BASE CASE IS HIT :\n\n         0           2            5  \n        [5,    1,    1,  2,  0  ,0]\n        lo           m           hi\n        lo     m     hi\n        lomhi \n        ^BASE CASE HIT  \n        \"\"\"\n        if lo &gt;=  hi  :\n            return\n        # print(self.nums, self.temp)\n        mid = (lo+hi)//2\n        self.sort(lo,mid)\n        self.sort(mid+1,hi)\n        self.merge(lo,mid,hi)\n\n    def sortArray(self, nums: List[int]) -&gt; List[int]:\n        #For writing intermediate merge results \n        self.temp = [0]*len(nums)\n        #For accessing array which needs to be sorted\n        self.nums = nums\n        self.sort(0,len(nums)-1)\n        return self.nums\n</code></pre>"},{"location":"Algorithms/Merge_Sort/#sorting-a-linked-list","title":"Sorting a linked list","text":"<p>Sorting a linked list is easier. We can actually break up the linked list in two halves in each recursive call. Sort the two halves and finally merge them. The base case is when the linked list is empty or only has a single element.</p> <p>Pay attention to the difference in the recursive implementation for array and linked list.</p> <p>For arrays, we pass pointers to the merge function to denote subarrays to be merged. For linked lists, we actually split the list and pass two separate lists.</p> Code Merge Sort on Linked List <pre><code>\"\"\"\nSolution for : https://leetcode.com/problems/sort-list/description/\nRecursively  :\n  Split the list in two halves .\n  Sort first half\n  Sort second half\n  Merge the two SORTED halves.\n\"\"\"\n# Definition for singly-linked list.\n class ListNode:\n     def __init__(self, val=0, next=None):\n         self.val = val\n         self.next = next\n\nfrom typing import Optional\n\nclass Solution:\n    def split_list(self, head: Optional[ListNode]) -&gt; (Optional[ListNode],Optional[ListNode]) :\n        \"\"\"\n        Splitting the list into two :\n        dummy-&gt;1-&gt; 2 -&gt;3-&gt;None\n            sf\n               s   f\n                   s      f  \n        s.next -&gt; second half  # s.next = None\n        dummy.next --&gt; first half\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        s,f = dummy,dummy \n        while f and f.next :\n            f = f.next.next\n            s = s.next\n        #slow pointer stops at the PREVIOUS NODE of second half\n        second_half = s.next\n        s.next = None\n        first_half = dummy.next\n        # print(\"first half\" , first_half)\n        # print(\"second half\", second_half)\n        return first_half,second_half\n\n    def merge(self,list1 : Optional[ListNode] , list2 : Optional[ListNode]) -&gt; Optional[ListNode] : \n        p1, p2  = list1,list2\n        # print(\"merging\", p1, \" and \", p2)\n        dummy = ListNode(0)\n        p3 = dummy\n\n        while p1 and p2 :\n            if p1.val &lt; p2.val:\n                p3.next = p1\n                p1 = p1.next\n            else: \n                p3.next = p2\n                p2 = p2.next\n            p3 = p3.next\n\n        if p1 :\n            p3.next = p1\n        if p2 :\n            p3.next = p2\n        # print(\"merged\" , dummy.next)\n        return dummy.next \n\n    def _sort(self,head) :\n        if not head or not head.next :\n            return head\n        #We first SPLIT the list halves\n        first_half, second_half = self.split_list(head)\n        #Then we SORT both halves\n        #Sorting is not in place\n        #So, you have to pass the sorted lists to merge\n        sorted_first_half = self._sort(first_half)\n        sorted_second_half = self._sort(second_half)\n        #Merge the sorted halves\n        return self.merge(sorted_first_half,sorted_second_half)\n\n\n    def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        return self._sort(head)\n</code></pre>"},{"location":"Algorithms/Merge_Sort/#important-things-to-note","title":"Important things to note","text":"<p>As we saw earlier, quicksort is just an application of array partitioning where we can think of a partition happening at the preorder position in the traversal of a binary tree. Similarly : </p> <p>tl;dr</p> <p>Merge sort is an application of 2-way merge where we can think of a merge happening in the post order position of a binary tree traversal.</p>"},{"location":"Algorithms/Quickselect/","title":"QuickSelect","text":""},{"location":"Algorithms/Quickselect/#defining-the-problem","title":"Defining the problem.","text":"<p>Given an array, find the sorted value in non decreasing order at the kth index (Lets assume indices are counted from zero). </p> <p>In other words what would be the value at the kth index if the array were sorted in non decreasing order?</p> <p>This is also called the kth order statistic.</p>"},{"location":"Algorithms/Quickselect/#the-algorithm","title":"The Algorithm","text":"<p>The core of the quickselect algorithm is the partitioning scheme. There are different ways of implementing quickselet based on whether the partitioning scheme puts the pivot in its sorted position or not. Here we will consider only the implementation which uses partition schemes which do, because this is simpler and more intuitive.</p> <p>Assume, you have a partitioning scheme which returns some partition index / pivot index s.t. the value at the pivot index is in its sorted position. The quickeselect algorithm makes one recursive call based on the relative position of k to the pivot index. The base case is when the pivot index is k.</p> <p>Algorithm</p> <pre><code>def quickselect(arr,lo,hi, k ) :\n    p = partition(arr,lo,hi)\n    if p == k :\n       return arr[k]\n    elif  k&lt; p :\n       return quickselect(arr,lo,p-1,k)\n    else :\n       return quickselect(arr,p+1,hi,k)\n</code></pre> <p>Here is the implementation using Hoare partitionining.Notice the difference that random pivot selection makes in the comments :</p> Code Hoare Partition with Weak Condition and fixed pivotHoare Partition with Weak Condition and random pivot <pre><code>        from typing import List\n        import random\n\n        def quickselect(arr: List[int],lo: int,hi: int,k : int) -&gt; int :\n            \"\"\"\n            Quickselect using Hoare partition with a weak condition and fixed pivot. \n\n            This is the implementation which you will find in textbooks using do..while style loops which in python becomes while True loops.\n            I prefer avoiding white True loops. \n            It's still using Hoare partition with a weak condition. But the pivot selection is not random.\n            Notice how the performance degrades to O(n^2) for sorted input array because the pivot selection is not random.\n            Compare this with next version which uses a random pivot.\n            \"\"\"\n            v = arr[lo]\n            i = lo\n            j = hi+1\n            while True:\n                while True:\n                    i += 1\n                    if not (i &lt; hi and arr[i] &lt; v):\n                        break\n                while True:\n                    j -= 1\n                    if not (j &gt; lo and arr[j] &gt; v):\n                        break\n                if i &gt;= j:\n                    break\n                arr[i], arr[j] = arr[j], arr[i]\n            arr[lo], arr[j] = arr[j], arr[lo]\n\n            print(f\"Pivot Value: {v}  ,Partitioned list : {arr}, Partition Index = {j} , le = {lo}, hi = {hi}, k = {1}\")\n            if k -1  == j :\n                print(f\"Returning index {j}\")\n                return nums[j]\n            elif k -1 &gt; j : \n                return quickselect(nums,j+1,hi,k)\n            else :\n                return quickselect(nums,lo,j-1,k)\n\n        if __name__ == \"__main__\" :\n            # nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,1,1,1,1,1,1,1,1,1,1,1-2,-5]               # O(nlogn)\n            nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  # O(nlogn)\n            # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]  #degrades to O(n^2)\n            # nums = [24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]  #O(nlogn)\n            print( \n                   f\"kth_largest = { quickselect(nums, 0, len(nums)-1 ,23) }\" \n                  )\n\n            # nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] # O(nlogn)\n            # print( \n            #        f\"kth_largest = { quickselect(nums, 0, len(nums)-1 ,1) }\" \n            #       )\n</code></pre> <pre><code>         from typing import List\n         import random\n\n\n         def hoare_partition(arr, lo, hi):\n             \"\"\"\n             Entropy Optimal Hoare partition.\n             Produces balanced partitions when there are large number of duplicates.\n             [lo,right] contains elements less than or equal to pivot.\n             (right,hi]  contains elements greater than or equal to pivot.\n             Invariants for the while loop :\n             [lo] has pivot  \n             [lo, left)  &lt;= pivot    #Has values &lt;= pivot\n             (right, hi] &gt;= pivot\n             [pivot|--- &lt;=pivot-----|-----Undetermined-------|---&gt;=pivot----]\n                                     left               right\n             After execution of while loop : \n             [pivot|----&lt;=pivot------|-----&gt;=pivot------]\n             lo                  right                  hi\n             [lo,right] &lt;= pivot\n             After Putting pivot in sorted position : \n             [----&lt;=pivot----|pivot|-----&gt;=pivot------]\n             lo               right                  hi\n             Finally, return right.\n             \"\"\"\n             #PIVOT SELECTION\n             #Pick a random pivot index and always keep pivot at index lo\n             #NB:  random.randint(0,0) is 0.\n             pivot_index = random.randint(lo,hi)\n             arr[lo],arr[pivot_index] =  arr[pivot_index],arr[lo]\n             #read pivot value\n             pivot = arr[lo]\n\n             #PARTITIONING\n             #partition [lo+1,hi] ; \n             #NB : when lo == hi , while loop will not be executed\n             left,right = lo+1, hi\n             while left&lt;=right:\n                 #Move left ahead if arr[left] is strictly less than pivot value\n                 while left &lt;= right and arr[left] &lt; pivot :\n                     left+=1\n                 #Move right to the left if it is strictly higher than pivot\n                 while left &lt;= right  and arr[right] &gt; pivot :\n                     right-=1\n                 #Swap left and right and move pointers\n                 #If both values are equal to pivot this will do a swap,move pointers and effectively leave pivot values where they are. \n                 if left &lt;=  right :\n                     arr[left], arr[right] = arr[right], arr[left]\n                     right-=1\n                     left+=1\n             #Put pivot in sorted position\n             arr[lo], arr[right] = arr[right], arr[lo]\n             return right\n\n         def quickselect(arr: List[int],lo: int,hi: int,k : int) -&gt; int :\n             \"\"\"\n             Quicselect using Hoare partition with weak condition and random pivot.\n             Return vlaue at Kth SMALLEST Index,\n             Returns the non decreasingly sorted value at kth Index with indices starting from lo. [lo ,hi] is inclusive.\n             This uses Hoare's partition scheme with a weak condition and which also puts pivot in its sorted position.\n             \"\"\" \n             pivot_index = hoare_partition(arr,lo,hi)\n             print(f\"Pivot Value: {arr[pivot_index]}  ,Partitioned list : {arr}, Partition Index = {pivot_index} , le = {lo}, hi = {hi}, k = {k}\")\n             if k == pivot_index :\n                 return arr[k]\n             if k &lt; pivot_index :\n                 return quickselect(arr,lo, pivot_index-1,k)\n             elif k &gt; pivot_index :  \n                  return quickselect(arr,pivot_index+1,hi,k)\n\n\n\n         if __name__ == \"__main__\" :\n             # nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,1,1,1,1,1,1,1,1,1,1,1-2,-5]                 # O(nlogn)\n             # nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  # Close to O(nlogn)\n             nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]  #STill close to O(nlogn) . WIthout random pivot degrades to O(n^2)\n             # nums = [24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]  #O(nlogn)\n             print( \n                    f\"kth_largest = { quickselect(nums, 0, len(nums)-1 ,23) }\" \n                   )\n</code></pre>"},{"location":"Algorithms/Quickselect/#additional-resources","title":"Additional Resources","text":"<ol> <li>https://en.wikipedia.org/wiki/Median_of_medians</li> </ol>"},{"location":"Algorithms/Quicksort/","title":"QuickSort","text":""},{"location":"Algorithms/Quicksort/#defining-the-problem","title":"Defining the problem.","text":"<p>Given an array, sort it in non decreasing order.</p>"},{"location":"Algorithms/Quicksort/#the-algorithm","title":"The Algorithm","text":"<p>Once you understand partitioning, quickselect and quicksort are just recursive applications of it. In quickselect, we make a single recursive call, while in quicksort, we make two recursive calls to eventually put all elements in their sorted position. Quick Sort can be visualized as a preorder traversal of a binary tree, where in the preorder position, you call the partitioning function and recursively call quicksort on both partitions. The base case is when lo &gt;= hi.</p> <p>Assume, you have a partitioning scheme which returns some partition index / pivot index s.t. the value at the pivot index is in its sorted position.</p> <p>The algorithm is :</p> <p>Algorithm</p> <pre><code>def quicksort(arr,lo,hi, k ) :\n    if lo &gt;= hi  :\n       return \n    p = partition(arr,lo,hi)\n    quicksort(arr,lo,p-1,k)\n    quicksort(arr,p+1,hi,k)\n</code></pre> <p>Implementation using Hoare Partitioning :</p> Code Hoare Partition with Weak Condition and random pivot <pre><code>         from typing import List\n         import random\n\n\n         def hoare_partition(arr, lo, hi):\n             \"\"\"\n             Entropy Optimal Hoare partition.\n             Produces balanced partitions when there are large number of duplicates.\n             [lo,right] contains elements less than or equal to pivot.\n             (right,hi]  contains elements greater than or equal to pivot.\n             Invariants for the while loop :\n             [lo] has pivot  \n             [lo, left)  &lt;= pivot    #Has values &lt;= pivot\n             (right, hi] &gt;= pivot\n             [pivot|--- &lt;=pivot-----|-----Undetermined-------|---&gt;=pivot----]\n                                     left               right\n             After execution of while loop : \n             [pivot|----&lt;=pivot------|-----&gt;=pivot------]\n             lo                  right                  hi\n             [lo,right] &lt;= pivot\n             After Putting pivot in sorted position : \n             [----&lt;=pivot----|pivot|-----&gt;=pivot------]\n             lo               right                  hi\n             Finally, return right.\n             \"\"\"\n             #PIVOT SELECTION\n             #Pick a random pivot index and always keep pivot at index lo\n             #NB:  random.randint(0,0) is 0.\n             pivot_index = random.randint(lo,hi)\n             arr[lo],arr[pivot_index] =  arr[pivot_index],arr[lo]\n             #read pivot value\n             pivot = arr[lo]\n\n             #PARTITIONING\n             #partition [lo+1,hi] ; \n             #NB : when lo == hi , while loop will not be executed\n             left,right = lo+1, hi\n             while left&lt;=right:\n                 #Move left ahead if arr[left] is strictly less than pivot value\n                 while left &lt;= right and arr[left] &lt; pivot :\n                     left+=1\n                 #Move right to the left if it is strictly higher than pivot\n                 while left &lt;= right  and arr[right] &gt; pivot :\n                     right-=1\n                 #Swap left and right and move pointers\n                 #If both values are equal to pivot this will do a swap,move pointers and effectively leave pivot values where they are. \n                 if left &lt;=  right :\n                     arr[left], arr[right] = arr[right], arr[left]\n                     right-=1\n                     left+=1\n             #Put pivot in sorted position\n             arr[lo], arr[right] = arr[right], arr[lo]\n             return right\n\n         def quicksort(arr: List[int],lo: int,hi: int) -&gt; int :\n             \"\"\"\n             Quicksort using Hoare partition with weak condition and random pivot.\n             This uses Hoare's partition scheme with a weak condition and which also puts pivot in its sorted position.\n             \"\"\" \n             if lo &gt;= hi :\n                 return\n             p = hoare_partition(arr,lo,hi)\n             quicksort(arr,lo, p-1)\n             quicksort(arr,p+1,hi)\n\n\n\n         if __name__ == \"__main__\" :\n             nums = [24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]\n             quicksort(nums,0,len(nums)-1)\n             print (nums)\n</code></pre>"},{"location":"Algorithms/Quicksort/#additional-references","title":"Additional References :","text":"<p>https://algs4.cs.princeton.edu/23quicksort/</p>"},{"location":"Algorithms/Two_Way_Merge/","title":"Merging Sorted Containers","text":"<p>Before considering K-way merge, let us first look at the simpler version of the problem.</p>"},{"location":"Algorithms/Two_Way_Merge/#the-2-way-merge-problem","title":"The 2-Way merge problem.","text":""},{"location":"Algorithms/Two_Way_Merge/#merging-two-sorted-arrays","title":"Merging two sorted arrays","text":"<p>Given 2 integer arrays, sorted in non decreasing order, merge them into a single sorted array. </p> Code Two Way Merge on ArraysUnit Tests for Two Merge on Arrays <pre><code>from typing import List\n\ndef merge_two(arr1 :  List[int], arr2 : List[int]) -&gt; List[int] :\n    \"\"\"\n    Given two arrays sorted in non decreasing order, return a merged array \n    \"\"\"\n\n    m, n = len(arr1) , len(arr2)\n\n    res = [0]*(m+n)\n\n    p1,p2,p3 = 0,0,0\n\n    while p1 &lt; m  and p2 &lt; n  :\n\n        if arr1[p1] &lt; arr2[p2] : \n            res[p3] = arr1[p1]\n            p3+=1\n            p1+=1\n        else :\n            res[p3] = arr2[p2]\n            p3+=1\n            p2+=1\n\n\n    while p1 &lt; m :\n        res[p3] = arr1[p1]\n        p1+=1\n        p3+=1\n\n    while p2 &lt; n :\n        res[p3] = arr2[p2]\n        p2+=1\n        p3+=1\n\n    return res\n\n\nif __name__ == \"__main__\" :\n    print(merge_two([4,5,7] , [3,6,7,8]))\n    print(merge_two([4,5,7] , [3,6]))\n    print(merge_two([] , [1,2,3]))\n    print( merge_two( [1, 2, 2, 5] , [2, 3, 4, 4] ) ) # [1, 2, 2, 2, 3, 4, 4, 5]\n    print( merge_two( [1, 3, 5, 7] , [2, 4, 6, 8] ) ) # [1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre> <pre><code>\"\"\"\nUnit Tests for Two way merge.\n\n# Aside : See these for an introduction to pytest : https://realpython.com/pytest-python-testing/\n              https://gist.github.com/kwmiebach/3fd49612ef7a52b5ce3a\n\"\"\"\nimport pytest\nfrom two_way_merge import merge_two \n\n\n# --- Test Cases ---\n\ndef test_merge_basic():\n    \"\"\"Tests merging two non-empty lists.\"\"\"\n    arr1 = [1, 3, 5, 7]\n    arr2 = [2, 4, 6, 8]\n    expected = [1, 2, 3, 4, 5, 6, 7, 8]\n    # Note: The original buggy code might return [1, 2, 3, 4, 5, 6, 7, 9]\n    assert merge_two(arr1, arr2) == expected\n\ndef test_merge_empty_first():\n    \"\"\"Tests merging when the first list is empty.\"\"\"\n    arr1 = []\n    arr2 = [2, 4, 6]\n    expected = [2, 4, 6]\n    assert merge_two(arr1, arr2) == expected\n    # Test swap logic too\n    assert merge_two(arr2, arr1) == expected\n\ndef test_merge_empty_second():\n    \"\"\"Tests merging when the second list is empty.\"\"\"\n    arr1 = [1, 3, 5]\n    arr2 = []\n    expected = [1, 3, 5]\n    assert merge_two(arr1, arr2) == expected\n    # Test swap logic too\n    assert merge_two(arr2, arr1) == expected\n\ndef test_merge_both_empty():\n    \"\"\"Tests merging when both lists are empty.\"\"\"\n    arr1 = []\n    arr2 = []\n    expected = []\n    assert merge_two(arr1, arr2) == expected\n\ndef test_merge_duplicates():\n    \"\"\"Tests merging lists with duplicate numbers.\"\"\"\n    arr1 = [1, 2, 2, 5]\n    arr2 = [2, 3, 4, 4]\n    expected = [1, 2, 2, 2, 3, 4, 4, 5]\n    # Note: Original buggy code might return [1, 2, 2, 2, 3, 4, 4, 9]\n    assert merge_two(arr1, arr2) == expected\n\ndef test_merge_duplicates_across_lists():\n    \"\"\"Tests merging lists where duplicates exist between lists.\"\"\"\n    arr1 = [1, 3, 5]\n    arr2 = [1, 3, 5]\n    expected = [1, 1, 3, 3, 5, 5]\n    # Note: Original buggy code might return [1, 1, 3, 3, 5, 9]\n    assert merge_two(arr1, arr2) == expected\n\ndef test_merge_interleaved():\n    \"\"\"Tests merging lists with highly interleaved numbers.\"\"\"\n    arr1 = [1, 4, 5, 8]\n    arr2 = [2, 3, 6, 7]\n    expected = [1, 2, 3, 4, 5, 6, 7, 8]\n    # Note: Original buggy code might return [1, 2, 3, 4, 5, 6, 7, 9]\n    assert merge_two(arr1, arr2) == expected\n\ndef test_merge_one_list_much_shorter():\n    \"\"\"Tests merging when one list is significantly shorter.\"\"\"\n    arr1 = [1, 2, 10, 11, 12]\n    arr2 = [3, 4]\n    expected = [1, 2, 3, 4, 10, 11, 12]\n    # Note: Original buggy code might return [1, 2, 3, 4, 10, 11, 9]\n    assert merge_two(arr1, arr2) == expected\n    # Test swap logic too\n    assert merge_two(arr2, arr1) == expected # Should give same result\n\ndef test_merge_all_elements_smaller():\n    \"\"\"Tests merging when all elements of one list are smaller than the other.\"\"\"\n    arr1 = [1, 2, 3]\n    arr2 = [4, 5, 6]\n    expected = [1, 2, 3, 4, 5, 6]\n    # Note: Original buggy code might return [1, 2, 3, 4, 5, 9]\n    assert merge_two(arr1, arr2) == expected\n    # Test swap logic too\n    assert merge_two(arr2, arr1) == expected # Should give same result\n\ndef test_merge_negative_numbers():\n    \"\"\"Tests merging lists with negative numbers.\"\"\"\n    arr1 = [-5, -1, 0, 10]\n    arr2 = [-3, -2, 8, 12]\n    expected = [-5, -3, -2, -1, 0, 8, 10, 12]\n    # Note: Original buggy code might return [-5, -3, -2, -1, 0, 8, 10, 9]\n    assert merge_two(arr1, arr2) == expected\n\ndef test_merge_single_element_lists():\n    \"\"\"Tests merging lists with single elements.\"\"\"\n    arr1 = [5]\n    arr2 = [2]\n    expected = [2, 5]\n    # Note: Original buggy code might return [2, 9] due to off-by-one loop\n    assert merge_two(arr1, arr2) == expected\n    assert merge_two(arr2, arr1) == expected\n</code></pre>"},{"location":"Algorithms/Two_Way_Merge/#merging-two-sorted-lists","title":"Merging two sorted lists","text":"<p>The same thing for a linked list :</p> Code Two Way Merge on Lists <pre><code>\"\"\"\nSolution for  https://leetcode.com/problems/merge-two-sorted-lists/description/\n\"\"\"\nfrom typing import Optional\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        p1, p2  = list1,list2\n        dummy = ListNode(0)\n        p3 = dummy\n\n        while p1 and p2 :\n            if p1.val &lt; p2.val:\n                p3.next = p1\n                p1 = p1.next\n            else: \n                p3.next = p2\n                p2 = p2.next\n            p3 = p3.next\n\n        if p1 :\n            p3.next = p1\n        else :\n            p3.next = p2\n\n        return dummy.next \n</code></pre> <p>So, how are we solving the problem of two way merging?</p> <p>We have a write pointer p3 and we have two read pointers, p1 and p2. In each iteration of the while loop, we pick the smaller read pointer to write to the write location and move both pointers (write pointer and one of the read pointers) ahead.</p> <p>If either p1 or p2 have still not reached the end of their read containers, we just write the rest of that read container at the write pointer.</p>"},{"location":"Algorithms/recursive/1_basics/","title":"Basic Recursion","text":"<p>Understand what happens when you \"do\" something before the recursive call (preorder position) or after the recursive call (postorder position). Debug this and see what is happening on the stack and how function calls are stacked and unwound.</p>"},{"location":"Algorithms/recursive/2_backtracking/","title":"Backtracking","text":"<p>Backtracking seems and difficult to learn, because there are so many different ways of doing the same thing.</p> <p>Here, we solve the same problem in many different ways only to see the possibilities.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/","title":"Anatomy of an AWS Policy","text":"<p>AWS Policies are json documents which declare the access permissions for certain services or resources at a granular level. They can be attached to roles, users or resources. Let us understand how this works by looking at an example policy. </p>","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#the-philosophy-of-aws-security","title":"The philosophy of AWS Security","text":"<p>AWS IAM operates on the principle of the shared responsibility model. This means AWS provides the MEANS of implementing security but YOU are responsible for using them effectively. This means having to manage lots of policies.</p> <p>Another important principle is the principle of LEAST PRIVILEGE. In case of a hypthetical security breach, the BLAST RADIUS should be as small as possible.</p> <p>Blast Radius for the following policy is a single Lambda Function being invoked: </p> <pre><code>{\n          \"Version\": \"2012-10-17\",\n          \"Statement\": [\n            {\n              \"Sid\": \"VisualEditor1\",\n              \"Effect\": \"Allow\",\n              \"Action\": \"lambda:InvokeFunction\",\n              \"Resource\": [\n                \"arn:aws:lambda:&lt;your_account_id&gt;:&lt;us-east-1&gt;:function:MyFunction\"\n              ]\n            }\n          ]\n}\n</code></pre> <p>Now , if you want to use a generic role to invoke ANY lambda function in the acccount, you would use a wild card in the Resource : \"arn:aws:lambda:::function:*\" . <p>Now the blast radius is invocation of any function.</p> <p>And if you want to have a generic role which can pretty much do anything with lambda functions like create, modify, delete and invoke lambdas, you would use a wildcard to define the Action as \"lambda:*\". So, the blast radius just increased to include anything which can be done to or with lambda functions. Somebody could just list and delete all your lambda functions.</p>","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#when-does-iam-apply","title":"When does IAM apply?","text":"<p>Whenever you request anything through an AWS API its going to go through IAM. But but, there is a case when it does not apply : When you have an HTTP server running on an AWS EC3 instance and http requests are directly made to the elastic ip address, there is no AWS service in between, so no IAM policy evaluation is done in this case.</p> <pre><code>{\n          \"Version\": \"2012-10-17\",\n          \"Statement\": [\n            {\n              \"Sid\": \"VisualEditor1\",\n              \"Effect\": \"Allow\",\n              \"Action\": \"lambda:InvokeFunction\",\n              \"Resource\": [\n                \"arn:aws:lambda:&lt;your_account_id&gt;:&lt;us-east-1&gt;:function:MyFunction\"\n              ]\n            }\n          ]\n}\n</code></pre>","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#trust-policy","title":"TRUST POlICY","text":"<p>A trust policy is an IAM policy attached to a Role which specifies who (which Principal) can assume it. This is typically used to allow services to assume the role. A typical example is API Gateway assuming a role which Has permissions to invoke a Lambda function.</p> <p>https://aws.amazon.com/blogs/security/how-to-use-trust-policies-with-iam-roles/</p>","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#invocation-role-vs-execution-role","title":"Invocation Role vs Execution Role","text":"<p>A question may arise: Does the invoking role/user need all the permisions of the execution role? Say, a user does not have direct permission to delete an item from an s3 bucket, but he does have access to invoke a lambda function which can perform this action through its execution role. Can the user invoke the lambda and delete files? The answer is yes. Once the Lambda is invoked it autmoatically assumes the execution roles and performs whatever actions it does with the execution role. </p> <p>\"The policies that are attached to the credentials that made the original call to AssumeRole are not evaluated by AWS when making the \"allow\" or \"deny\" authorization decision. The user temporarily gives up its original permissions in favor of the permissions assigned by the assumed role. In the case of the AssumeRoleWithSAML and AssumeRoleWithWebIdentity API operations, there are no policies to evaluate because the caller of the API is not an AWS identity.\" [Ref 5]</p>","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#resource-policies","title":"Resource Policies","text":"","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#a-special-note-on-s3-policies","title":"A special Note on S3 Policies","text":"<p>When it comes to S3 buckets there two types of ARNs 1. ARN to match the bucket : arn:aws:s3:::my-bucket 2. ARN to match objects: arn:aws:s3:::my-bucket/ , arn:aws:s3:::my-bucket/somepath/ ,arn:aws:s3:::my-bucket/somepath/*, arn:aws:s3:::my-bucket/somepath/somekey.txt</p> <p>There are also two types of actions : Bucket level and Object level. </p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\"s3:GetObject\", \"s3:ListBucket\"],\n            \"Resource\": [\n                \"arn:aws:s3:::mybucket\",\n                \"arn:aws:s3:::mybucket/resports/diabetes/*\"\n            ]\n        }\n    ]\n}\n</code></pre> <p>In the policy above, s3:ListBucket applies to the Bucket ARN and s3:GetObject applies to the arn matching objects with this pattern mybucket/resports/diabetes/*. A clearer way to write the same policy is using two separate statemnets, one for bucket level actions and another for Object level actions :</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\"s3:ListBucket\"],\n            \"Resource\": \"arn:aws:s3:::mybucket\"\n        }.\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::mybucket/reports/diabetes/*\"\n        }\n    ]\n}\n</code></pre> <p>The most common example of Bucket Level action is ListBucket. PutObject, GetObject are examples of  Object Level actions.</p> <p>A common mistake when writing bucket policies is not including the bucket arn as a Resource in the policy. Then you will be left wondowering why I cannot list operations fail even though I have s3:Listbucket action in my policy.</p>","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#cross-account-resource-access","title":"Cross account resource access","text":"<p>Consider this quote from S3 ducumentation : </p> <p>\"If the requester is an IAM principal, Amazon S3 must determine if the parent AWS account to which the principal belongs has granted the principal necessary permission to perform the operation. In addition, if the request is for a bucket operation, such as a request to list the bucket content, Amazon S3 must verify that the bucket owner has granted permission for the requester to perform the operation. To perform a specific operation on a resource, an IAM principal needs permission from both the parent AWS account to which it belongs and the AWS account that owns the resource\"  [ Ref 7 ]</p> <p>This applies in general to any resource. What this means in practice is :</p> <ol> <li> <p>If the principal and the resource belong to the same account: Either the resource policy OR the policy attached to the principal (i.e. user/role) should explicitly Allow the action on the target resource.</p> </li> <li> <p>If they belong to different accounts: Both, the resource policy AND the policy attached to the principal (i.e. user/role) MUST explicitly Allow the action on the target resource.</p> </li> </ol>","tags":["AWS","IAM"]},{"location":"blog/Anatomy%20of%20an%20AWS%20Policy/#references","title":"References","text":"<ol> <li> <p>https://docs.aws.amazon.com/pdfs/whitepapers/latest/aws-fault-isolation-boundaries/aws-fault-isolation-boundaries.pdf</p> </li> <li> <p>https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html</p> </li> <li> <p>https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html</p> </li> <li> <p>https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-cli.html</p> </li> <li> <p>https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html</p> </li> <li> <p>https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html</p> </li> <li> <p>https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html#supported-arns</p> </li> <li> <p>https://docs.aws.amazon.com/AmazonS3/latest/userguide/how-s3-evaluates-access-control.html</p> </li> </ol>","tags":["AWS","IAM"]},{"location":"blog/test/","title":"Building Serverless ETL Pipelines on AWS","text":"<p>In this post, I'll share my experience building a serverless ETL pipeline to extract and map medical entities using various AWS services including Lambda, SNS, Textract, Translate, Comprehend Medical, Glue, and Athena.</p>","tags":["tag1","tag2"]},{"location":"blog/test/#the-challenge","title":"The Challenge","text":"<p>Working at Genentech, I faced the challenge of extracting medical entities from multilingual clinical notes that came in various formats including handwritten images, PDFs, and DOCX files. These entities needed to be mapped to standardized ICD-10 codes for analysis.</p>","tags":["tag1","tag2"]},{"location":"blog/test/#architecture-overview","title":"Architecture Overview","text":"<p>Our solution leveraged a serverless architecture with these key components:</p> <ol> <li>Document Ingestion: AWS S3 for storage with event triggers</li> <li>Text Extraction: AWS Textract for converting documents to machine-readable text</li> <li>Translation: AWS Translate for handling multilingual content</li> <li>Entity Recognition: AWS Comprehend Medical for identifying medical terms</li> <li>Code Mapping: Custom Lambda function to map to ICD-10 codes</li> <li>Data Storage: Processed results stored in S3 and cataloged in Glue</li> <li>Analysis: Athena for SQL-based querying of the processed data</li> </ol>","tags":["tag1","tag2"]},{"location":"blog/test/#implementation-details","title":"Implementation Details","text":"<p>[Content continues with technical implementation details]</p>","tags":["tag1","tag2"]},{"location":"blog/test/#benefits-and-results","title":"Benefits and Results","text":"<p>The serverless approach provided several advantages:</p> <ol> <li>Cost Efficiency: Pay-per-use model reduced operational costs by 40%</li> <li>Scalability: Automatic scaling handled varying document loads</li> <li>Maintenance: Reduced operational overhead compared to EC2-based solutions</li> <li>Accuracy: Achieved 92% accuracy in entity recognition and mapping</li> </ol>","tags":["tag1","tag2"]},{"location":"blog/test/#lessons-learned","title":"Lessons Learned","text":"<p>[Content continues with lessons learned and best practices]</p>","tags":["tag1","tag2"]},{"location":"blog/test/#conclusion","title":"Conclusion","text":"<p>Serverless ETL pipelines offer significant advantages for processing unstructured medical data at scale. By leveraging AWS's managed services, we created a solution that was both cost-effective and powerful.</p> <p>Feel free to reach out if you have questions about implementing similar solutions in your organization!</p>","tags":["tag1","tag2"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/","title":"Fun Facts about two's complement encoding","text":"<p>While revisiting my old notes on Standard C , I came across this fun fact: In two\u2019s complement, values like 0xF, 0xFF, and 0xFFFF all represent -1. Let's see why this is and explore some other properties of 2's complement encoding. </p>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#signed-vs-unsigned-encoding-for-integers","title":"SIgned Vs Unsigned encoding for integers","text":"<p>Most computers use two\u2019s complement to represent negative values. In this system, the most significant bit (MSB) is treated as having a negative weight.</p> <p>Unsigned Example: 1111 \u2192 8 + 4 + 2 + 1 = 15</p> <p>Signed Example: 1111 \u2192 -8 + 4 + 2 + 1 = -1</p> <p>This means: - 0xF = -1 - 0xFF = -1 - 0xFFF = -1 - 0xFFFF = -1 \u2026and so on, for all bits set in any size.</p> <p>For a byte, numbers from 0x00 to 0x7F are positive and have the same encoding in both signed and unsigned (two\u2019s complement) form.</p>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#range-for-n-bit-signed-integers","title":"Range for N-bit Signed Integers","text":"<p>Let us dig a little bit deeper. What could be the the range for an N-Bit Signed Integer.</p> <p>The Lowest value would be if the Most Significant Bit is set and no other bit is set.</p> <p>For a 4- bit Integer: </p> <pre><code>BIT representation        :   1     0     0      0\nPostition Value of bits   :  2^3   2^2   2^1    2^0 \nSign                      :  Negative since MSB is set \nDecimal Value             : -8                     \n</code></pre> <p>The lowest value will always be -(2^(N-1))</p> <p>Conversely, the highest positive value will be when the MSB is not set and all other bits are set. This is equal to 2^(N-1) -1.</p> <p>For a 4- bit Integer: </p> <pre><code>BIT representation        :   0     1     1      1\nPostition Value of bits   :  2^3   2^2   2^1    2^0 \nSign                      :  Positive since MSB is not set \nDecimal Value             :  7                     \n</code></pre> <p>Did you also notice that -(2^(N-1)) + (2^(N-1)-1) = -1?</p> <p>This is why 0xFFFFF... is always -1 in 2's complement.</p>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#extension","title":"Extension","text":"<p>In fact, you can represent any N-bit signed integers in N+x bits bits simply by extending the Most Significant Bit x times.</p> <pre><code>    4-bit       8-bit       16-bit              Decimal\n    0111        00000111    0000000000000111    +7\n    1110        11111110    1111111111111110    -2\n</code></pre>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#truncation","title":"Truncation","text":"<p>An N-bit signed integer can be truncated to N-x bits and hold the same value by removing the Highest Order x Bits excluding the  MSB as long as they match the MSB (Sign Bit).</p> <pre><code>11100  is -4\n1100   is -4\n100    is -4\n10     is NOT -4 . It is -2.   \n</code></pre>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#getting-twos-complement-of-a-number","title":"Getting Two's Complement of a Number","text":"<p>For getting 2's complement of a number you  flip the bits and add 1.</p> <pre><code>4-bit   Decimal \n0011      3       \n1100     -4          \n1101     -3          #Two's complement of 0011\n</code></pre> <p>[ As two why this works see Ref 2 below ] </p>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#overflow-detection","title":"Overflow Detection","text":"<p>In 2's complement overflow is not possible when adding numbers with opposite signs. When adding numbers of the same sign, if there is an overflow you will get the wrong sign bit. </p> <ul> <li> <p>If both numbers are positive and you get a negative result.</p> </li> <li> <p>If both numbers ar negative and you get a positive result.</p> </li> </ul> <p>[Ref 1]</p>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#why-2s-complement","title":"Why 2's complement?","text":"<p>It's convenient. The same Adders in Hardware can be used for doing addition and subtraction. All you have to do is flip bits and add 1 to get the negative representation of a positive number and vice-versa.</p> <p>It is also Bijective, which is to say that it can uniquely represent negative integers, positive integers and zero.</p>","tags":["C","Basics"]},{"location":"blog/Fun%20Facts%20about%20two%27s%20complement%20encoding/#additional-references","title":"Additional References","text":"<ol> <li>https://web.archive.org/web/20131031093811/http://www.cs.uwm.edu/~cs151/Bacon/Lecture/HTML/ch03s09.html</li> <li>https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html</li> </ol>","tags":["C","Basics"]},{"location":"resources/","title":"Resources","text":"<p>A curated collection of learning materials, documentation, and references.</p>"},{"location":"resources/#learning-platforms-playgrounds","title":"Learning Platforms &amp; Playgrounds","text":""},{"location":"resources/#data-engineering","title":"Data Engineering","text":"<ul> <li>DataTalks Club</li> </ul>"},{"location":"resources/#containers-linux","title":"Containers &amp; Linux","text":"<ul> <li>Container &amp; Linux Learning Labs</li> </ul>"},{"location":"resources/#sql","title":"SQL","text":"<ul> <li>Mode SQL Tutorial</li> <li>JDBC - a short guide</li> </ul>"},{"location":"resources/#spark","title":"Spark","text":"<ul> <li>Spark Playground</li> </ul>"},{"location":"resources/#mlai","title":"ML/AI","text":"<ul> <li>AFAIK.io</li> </ul>"},{"location":"resources/#documentation-white-papers","title":"Documentation &amp; White Papers","text":""},{"location":"resources/#aws","title":"AWS","text":"<ul> <li>AWS Fault Isolation Boundaries</li> <li>Using Trust Policies with IAM Roles</li> <li>S3 Object Lifecycle Management</li> </ul>"},{"location":"resources/#azure","title":"Azure","text":"<ul> <li>Azure Architecture Center</li> <li>AWS IAM to Azure Concepts Mapping</li> <li>Azure for AWS Professionals - Security &amp; Identity</li> <li>AWS &amp; Azure AD Security Integration</li> <li>Big Data Architecture Style</li> </ul>"},{"location":"resources/#devops","title":"DevOps","text":"<ul> <li>Terraform Language Documentation</li> <li>Helm Documentation</li> <li>Terraform CLI Workspaces Guide</li> <li>Terraform Configuration Organization</li> </ul>"},{"location":"resources/#technical-blog-posts-articles","title":"Technical Blog Posts &amp; Articles","text":""},{"location":"resources/#sql-optimization","title":"SQL Optimization","text":"<ul> <li>Mastering EXPLAIN ANALYZE</li> <li>N+1 Query Problem</li> <li>GraphQL N+1 Problem</li> </ul>"},{"location":"resources/#dataframe-data-processing","title":"DataFrame &amp; Data Processing","text":"<ul> <li>SQL vs DataFrames Discussion</li> <li>10 Minutes to Dask</li> <li>TPC-H Benchmarks</li> <li>Dask Join Order Optimization</li> <li>Spark MapReduce Internals</li> </ul>"},{"location":"resources/#cloud-computing","title":"Cloud Computing","text":"<ul> <li>AWS App Runner Discussion</li> <li>AWS App Runner Issues</li> <li>Cloud Platform Comparison for Startups</li> </ul>"},{"location":"resources/#aiml","title":"AI/ML","text":"<ul> <li>LLM Document Summarization</li> <li>Text Chunking Strategies</li> <li>Podcast Transcripts Summarization</li> </ul>"},{"location":"resources/#books-long-form-content","title":"Books &amp; Long-form Content","text":""},{"location":"resources/#data-engineering_1","title":"Data Engineering","text":"<ul> <li>How Query Engines Work</li> <li>Data Engineering Design Patterns</li> </ul>"},{"location":"resources/#cloud-computing_1","title":"Cloud Computing","text":"<ul> <li>AWS SAP Certification Notes</li> <li>Azure Data Lakehouse Toolkit</li> </ul>"},{"location":"resources/#version-control","title":"Version Control","text":"<ul> <li>Pro Git Book</li> </ul>"},{"location":"resources/#web-development","title":"Web Development","text":"<ul> <li>HTTP Crash Course</li> </ul>"},{"location":"resources/#networking","title":"Networking","text":"<ul> <li>Networking Crash Course</li> </ul>"},{"location":"resources/#technical-blogs","title":"Technical Blogs","text":""},{"location":"resources/#data-engineering_2","title":"Data Engineering","text":"<ul> <li>AS Rathore's Blog</li> </ul>"},{"location":"resources/#sql_1","title":"SQL","text":"<ul> <li>Erland Sommarskog's SQL Blog</li> </ul>"},{"location":"resources/#ai-engineering","title":"AI Engineering","text":"<ul> <li>Amit Chaudhary's Blog</li> <li>Coding The Smart Way{}</li> </ul>"},{"location":"resources/#java","title":"Java","text":"<ul> <li>Marco Behler's Blog</li> </ul>"},{"location":"resources/#cheat-sheets","title":"Cheat Sheets","text":"<ul> <li>PySpark RDD Cheat Sheet</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/c/","title":"C","text":""},{"location":"blog/category/basics/","title":"Basics","text":""},{"location":"blog/category/encodings/","title":"Encodings","text":""},{"location":"blog/category/aws/","title":"AWS","text":""},{"location":"blog/category/iam/","title":"IAM","text":""},{"location":"blog/category/etl/","title":"ETL","text":""},{"location":"blog/category/serverless/","title":"Serverless","text":""}]}