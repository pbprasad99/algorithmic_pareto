{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to patibanb.me</p>"},{"location":"About/about/","title":"About","text":"<p>Coming Soon</p>"},{"location":"Algorithms/","title":"Algorithms","text":"<p>Notes on Algorithms.</p>"},{"location":"Algorithms/#philosophy","title":"Philosophy","text":"<p>Broadly, I classify any algorithm or data structure into recursive or iterative. Of course, this is not a strict demarcation, but only in terms of the usual implementations or concpetualization.</p> <p>As for data structures, there are two fundamental types in terms of how they are stored : contiguous storage (arrays, dynamic arrays) and linked storage (linked lists, trees, graphs) </p>"},{"location":"Algorithms/#mental-models","title":"Mental models","text":"<p>To effectively use a concept, it helps greatly to have the right mental model which allows you to use it in a consistent manner.</p> <p>For example, understanding and thinking of binary search in terms of bisect left and bisect right makes it easy to actually use it in a consistent manner.</p> <p>Another example, for array partitioning, just thinking of and  defining the loop invariant correctly is key. </p> <p>My effort is always to develop the correct understanding and mental model for any concept.</p>"},{"location":"Algorithms/#call-a-thing-by-its-right-name","title":"Call a thing by its right name","text":"<p>Just knowing the name of a thing is very powerful.  Know the name of the problem and know the name of the algorithm.</p>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/1_Hoare/","title":"Defining the problem","text":"<p>Let us consider the simplest version of the problem.</p> <p>Given an array of integers, rearrange the elements such that the left part contains elements less than or equal to a pivot value and the right part contains values greater than the pivot value.</p>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/1_Hoare/#the-algorithm-hoare-partition-with-strict-condition","title":"The algorithm - Hoare partition with strict condition","text":"<p>Consider this example array and a pivot value of 4   :</p> <p>[ 1 , 9, 3, 5, 7, 4, 8  ]</p> <p>If this array were already partitioned s.t. the left partition has only elements less than or equal to the pivot. These would hold true : <pre><code>Any element in left partition &lt;= pivot\nAny element in right partition &gt; pivot\n</code></pre> If we take left and right pointers  while verifying that arr[left] &lt;= pivot and arr[right] &gt; pivot, left and right pointers would move past each other before evaluating to False for the first time. Left pointer would end up at the BEGINNING of the right partition and the right pointer would end up at the END of the left partition.</p> <pre><code>[ 1,   3,     4,   5,   7,   8,   9 ]\n  L/T  L/T   L/T *L/F*                            # L = Left pointer, T = arr[left]&lt;= pivot is True , F = Its False\n            *R/F* R/T   R/T     R/T    R/T        # R = right pointer, T = arr[right] &gt; pivot is True, F = Its False   \n</code></pre> <p>If left evaluates to True while its less than right, it would mean that this element is in the wrong partition. This also implies that there must be an element in the right partition which belongs to the left partition. </p> <pre><code>[  1 ,   9,   3,   5,   7,   4,   8  ]         \n  L/T **L/F**                                    # L = Left pointer, T = arr[left]&lt;= pivot is True, F = Its False\n                          **R/F**   R/T          # R = right pointer, T = arr[right] &gt; pivot is True, F = Its False                \n</code></pre> <p>We can simply swap these and keep moving until left and right pass each other.</p> <p>So, the algorithm would be:</p> <pre><code>Invariant 1) [0,right] only contains elements less than or equal to pivot\nInvariant 2) (right, len(arr) -1] only contains elements greater than pivot\n\n\nWhile left &lt;= right :\n      while left&lt;=right and &gt; (Invaraint 1) is True :\n           left +=1\n      while left&lt;=right and (Invariant 2) is True :\n           right -=1\n      if left &lt; right :\n          swap left and right\nreturn right\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/1_Hoare/#the-algorithm-hoare-partition-with-weak-condition","title":"The algorithm - Hoare partition with weak condition","text":"<p>The problem with the partition scheme with a strict condition (where we always put pivot values  in one of the partitions) is that it produces unbalanced partitions when used in quickselect or quicksort.</p> <p>Consider if the above partition scheme were used in quickselect for finding the smallest element in an array of size n). </p> <p>What happens when all elements are duplicates :</p> <p><pre><code>    [1,1,1,1,1,1]\n     l         r   Iter 1 : 5  comparisons\n     l       r     Iter 2 : 4  comparisons\n     l     r       Iter 3 : 3  comparisons\n     l   r         Iter 4 : 2  comparisons\n     l r           Iter 5 : 1  comparisons\n     lr            Iter 6 : 0  comparisons\n</code></pre> Number of comparisons = SUM([1.....n]) = n(n+1)/2 = (n*2 + n ) /2 Therefore, Complexity is O(n^2)  in this case.</p> <p>To mitigate this, we could slightly modify the definition of our partitions :</p> <pre><code>Any element in left partition &lt;= pivot\nAny element in right partition &gt;= pivot\n</code></pre> <p>Invariant 1) [low,right] only contains elements less than OR EQUAL to pivot Invariant 2) (right, high] only contains elements greater OR EQUAL to pivot</p> <p>That is, pivot values are allowed to be in either partition.</p> <p>Our problem now becomes : </p> <p>Given an array of integers, rearrange the elements such that the left part contains elements less than or equal to a pivot value and the right part contains values greater than or equal to the pivot value.</p> <p>The implementation is tricky when handling values equal to pivot. </p> <p>We also stop scanning when left or right are equal to pivot in both partitions.  We swap and move the left and right pointers. After any swap, both partitions will increase by 1. Pivot values might end up in any partition.  This will also be the case when, left and right are both pointing to pivot value i.e. both partitions increase by 1 and there is a redundant swap between two pivot values.</p> <pre><code>While left &lt;= right :\n      while  left&lt;=right and left &lt; pivot :\n           left +=1\n      while left&lt;=right and right &gt; pivot:\n           right -=1\n      if left &lt;= right :\n          swap left and right\n          left-=1\n          right-=1\nreturn right\n</code></pre> <p>Let us see the behavior of quickselect with this scheme for the same case :</p> <pre><code>    [1,1,1,1,1,1]\n     l         r   Iter 1 : 5  comparisons\n     l   r         Iter 2 : 3  comparisons; This iteration returns r=0 and ends the loop\n     rl            Iter 2 END \n</code></pre> <p>The complexity is reduced to nLOG(n) now.</p>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/1_Hoare/#important-things-to-note","title":"Important things to Note:","text":"<p>This algorithm does not necessarily place the pivot in its sorted position. Or rather, the problem is not asking us to do this,</p> <p>This array is partitioned by 4 but 4 is not in its sorted position.</p> <pre><code>[ 1,   4,    3,  |5,   7,   8,   9 ]\n</code></pre> <p>We can put the pivot in its sorted position by swapping it with the right pointer after running the algorithm.  A good way to handle this is : 1) Ensure that  the pivot at the lowest index  . 2) Run the partitioning algorithm on the rest of the array. 3) Swap right with low.</p> <p>But again, this will not group multiple instances of pivot together if pivot is duplicated. That is another problem called three way partitioning.</p> <p>This algorithm is not stable. The relative order of elements will not be preserved. Naive partitioning using extra space is the only algorithm which preserves relative order of elements.</p> <p>Additional References : https://algs4.cs.princeton.edu/23quicksort/</p>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/1_Hoare/hoare_two_way_partition_1/","title":"<code>hoare_two_way_partition_1.py</code>","text":"<pre><code>from typing import List\n\n#Given a list return partition index after partition on the pivot index value\ndef partition(nums: List[int],lo,hi) -&gt; int :\n    \"\"\"\n    Hoare partition with strong condition. \n    There is no guarantee that pivot will be in its right place in this implementation.\n    All we get is that the first half has elements less than or equal to pivot.\n    Pivot can be any value in the array. (Pivot Value can actually be any arbitrary value in this version).\n    \"\"\"\n    pivot = nums[lo]\n    left,right = lo+1 ,hi\n\n    while left &lt;= right :\n        while left&lt;= right and nums[left] &lt;=  pivot :\n            left+=1\n        while right &gt;=  0  and nums[right] &gt; pivot :\n            right-=1\n        if left &lt; right :\n            nums[left],nums[right] = nums[right],nums[left]\n\n    print(f\"Pivot Value: {pivot} , Partitioned list : {nums}, Partition Index = {right}\")\n    return right\n\nif __name__ == \"__main__\" :\n    nums = [2,4,5,1,4,8,9]\n    partition(nums, 0, len(nums)-1)\n    nums = [2,2,2,2,2,2]\n    partition(nums, 0, len(nums)-1)\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/1_Hoare/hoare_two_way_partition_2/","title":"<code>hoare_two_way_partition_2.py</code>","text":"<pre><code>from typing import List\nimport random\n#Given a list return partition index after partition on the pivot index value\ndef partition(nums: List[int],lo,hi) -&gt; int :\n    \"\"\"\n    Hoare partition with strong condition.\n    Here we modififed the code slightly to:\n    Fix pivot value at index zero.\n    Partition by the pivot value.\n    Finally place the pivot  at the end of the left partition.\n    This implementation puts pivot in the sorted position as well after partitioning.\n    This version is  not 'entropy optimal' . That is, it does not lead to balanced partitions when there are a lot of duplicates. \n\n    WHy ? Consider,  if this partition scheme is used in quickselect for finding the smallest element in an array of size n). \n    What happens when all elements are duplicates (disregarding random pivot selection):\n    [1,1,1,1,1,1]\n     l         r   Iter 1 : 6  comparisons\n     l       r     Iter 2 : 5  comparisons\n     l     r       Iter 3 : 4  comparisons\n     l   r         Iter 4 : 3  comparisons\n     l r           Iter 5 : 2  comparisons\n     lr            Iter 6 : 1  comparisons\n\n    Number of comparisons = SUM([1.....n]) = n(n+1)/2 = (n*2 + n ) /2\n    Therefore, Complexity is O(n^2) \n    \"\"\"\n    print(f\"Input List : {nums}\")\n    left, right = lo,hi\n\n    #RANDOM PIVOT SELECTION\n    #Always keep pivot at index lo\n    # pivot_index = random.randint(lo,hi)\n    # nums[lo],nums[pivot_index] =  nums[pivot_index],nums[lo]\n\n    #PARTITIONING\n    left+=1\n    pivot_val = nums[lo]\n\n    while left &lt;= right :\n\n        while left &lt;= right and nums[left] &lt;= pivot_val :\n            left+=1\n\n        while right &gt;=  left  and nums[right] &gt; pivot_val :\n            right-=1\n\n        if left &lt; right :\n            #swap\n            nums[left],nums[right] = nums[right],nums[left]\n\n    #Put pivot Value in sorted  position\n    nums[lo] , nums[right] =  nums[right] ,nums[lo]\n    print(f\"Pivot Value: {pivot_val}  ,Partitioned list : {nums}, Partition Index = {right}\")\n    return right\n\nif __name__ == \"__main__\" : \n    # nums= [1,2,3]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,2,2,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,4,5,1,4,8,9]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3]\n    # partition(nums, 0, len(nums)-1)\n    nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,-2,-5]\n    partition(nums, 0, len(nums)-1)\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/1_Hoare/hoare_two_way_partition_3/","title":"<code>hoare_two_way_partition_3.py</code>","text":"<pre><code>from typing import List\nimport random\n\n\ndef partition(arr, lo, hi):\n    \"\"\"\n    Entropy Optimal Hoare partition.\n    Produces balanced partitions when there are large number of duplicates.\n    [lo,right] contains elements less than or equal to pivot.\n    (right,hi]  contains elements greater than or equal to pivot.\n    Invariants for the while loop :\n    [lo] has pivot  \n    [lo, left)  &lt;= pivot    #Has values &lt;= pivot\n    (right, hi] &gt;= pivot\n    [pivot|--- &lt;=pivot-----|-----Undetermined-------|---&gt;=pivot----]\n                            left               right\n    After execution of while loop : \n    [pivot|----&lt;=pivot------|-----&gt;=pivot------]\n    lo                  right                  hi\n    [lo,right] &lt;= pivot\n    After Putting pivot in sorted position : \n    [----&lt;=pivot----|pivot|-----&gt;=pivot------]\n    lo               right                  hi\n    Finally, return right.\n    \"\"\"\n    #PIVOT SELECTION\n    #Pick a random pivot index and always keep pivot at index lo\n    #NB:  random.randint(0,0) is 0.\n    pivot_index = random.randint(lo,hi)\n    arr[lo],arr[pivot_index] =  arr[pivot_index],arr[lo]\n    #read pivot value\n    pivot = arr[lo]\n\n    #PARTITIONING\n    #partition [lo+1,hi] ; \n    #NB : when lo == hi , while loop will not be executed\n    left,right = lo+1, hi\n    while left&lt;=right:\n        #Move left ahead if arr[left] is strictly less than pivot value\n        while left &lt;= right and arr[left] &lt; pivot :\n            left+=1\n        #Move right to the left if it is strictly higher than pivot\n        while left &lt;= right  and arr[right] &gt; pivot :\n            right-=1\n        #Swap left and right and move pointers\n        #If both values are equal to pivot this will do a swap,move pointers and effectively leave pivot values where they are. \n        if left &lt;=  right :\n            arr[left], arr[right] = arr[right], arr[left]\n            right-=1\n            left+=1\n    #Put pivot in sorted position\n    arr[lo], arr[right] = arr[right], arr[lo]\n    print(f\"Pivot Value: {pivot}  ,Partitioned list : {arr}, Partition Index = {right}\")\n    return right\n\nif __name__ == \"__main__\" : \n    # nums= [1,2,3]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,2,2,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums = [2,4,5,1,4,8,9]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3,2]\n    # partition(nums, 0, len(nums)-1)\n    # nums= [3]\n    # partition(nums, 0, len(nums)-1)\n    nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,-2,-5]\n    partition(nums, 0, len(nums)-1)\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/2_Lomuto/","title":"Defining the problem","text":"<p>Let us consider the simplaest case, that of an array of integers.</p> <p>Given an array of integers, rearrange the elements such that the left part contains elements less than or equal to a pivot value and the right part contains values greater than the pivot value.</p>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/2_Lomuto/#the-algorithm","title":"The Algorithm","text":"<p>The Lomuto partition fixes uses two forward iterators to maintains two invariants :</p> <p>[lo,s) contains only elements less than or equal to the pivot.  # Left closed Right open interval</p> <p>[s,f) contains elements larger than the pivot.      # Left closed right open interval</p> <p>Usually, pivot is fixed at hi. </p> <p>Initial conditions are :</p> <p>s, f = 0,0</p> <p>Both invariants are trivially true initially.</p> <p>During execution :</p> <pre><code>[---&lt;=pivot----|---&gt;pivot------|---Unexamined---|pivot] \nlo              s               f                    hi \n</code></pre> <p>s and f can be thought of as slow and fast pointers with s at the write position and f at the read position.</p> <p>The algorithm is </p> <pre><code>def partition(arr,lo,hi) :\n    s = lo\n    pivot = arr[hi]\n    for f in range(lo,hi+1) : \n         if arr[f] &lt;= pivot : \n              arr[s],arr[f] = arr[f],arr[s] #swap s and f\n              s+=1\n    return s-1      \n</code></pre> <p>Since [s,f] is a half closed interval, it is empty if  s and f are equal. If there is a gap, this interval is gauranteed to only contain elements greater than pivot, since a gap INCREASES as a result of f pointing to a value less than or equal to the pivot and s pointing to a value greater than pivot,  in the first place.</p> <p>Dry Run :</p> <pre><code>General case :\n     [ 1,  4,  7,  3,  1,  4 ]\n0      sf                      # Initial condition, pivot = 4, arr[f] &lt;= 4 is True,  s will be swapped with f and both will move ahead\n1          sf                  # arr[f] &lt;= 4 , swap s with f and move both ahead\n2              sf              # arr[f] &lt;=4 is False, s stays where it is and only f moves ahead\n3              s  f            # arr[f] &lt;=4 is True, swap s with f and move both ahead\n4    [ 1,  4,  3,  7,  1,  4 ]\n                   s   f       # arr[f] &lt;=4 is True, swap s with f and move both ahead\n5    [ 1,  4,  3,  1,  7,  4 ] # arr[f] &lt;=4 is True, swap s with f and move both ahead\n                       s   f\n6    [ 1,  4,  3,  1,  4,  7 ] # arr[f] &lt;=4 is True, swap s with f and move both ahead\n                           s   # For loop ends\nReturn s -1\n\nOnly one element :\n  [4]\n0  sf      #arr[f] &lt;= f is True, swap s with f and move both ahead\n1    sf\nReturn s-1\n\nSorted array \n  [1,2,3]\n0  sf           \n1    sf\n2      sf\n3        s\n\nreturn s-1\n\nReverse sorted array :\n  [ 3, 2, 1 ]\n0   sf               #Initial conditions, arr[s] &lt;= 1 is False, only f will move ahead\n1   s  f             #arr[s] &lt;= 1 is False, only f will move ahead          \n2   s     f          #arr[s] &lt;= 1 is True, s and f will be swapped and both will move ahead \n3 [ 1, 2, 3 ]\n       s     f       #for loop ends\nreturn s -1 \n\nReverse sorted array with duplicate keys:\n[3, 2 ,1, 1]\n s     f\n[1, 2 ,3, 1]\n    s     f\n[1, 1 ,3, 2]\n       s     f   # for loop ends, \nreturn s-1 \n\nDuplicate keys :\n[1 , 1, 1, 1]\n             sf\nreturn s-1\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/2_Lomuto/#variant-implementation","title":"Variant Implementation","text":"<p>We could redefine our problem statement slightly : Given an array of integers, rearrange the elements such that the left part contains elements less than or equal to a pivot value and the right part contains values greater than the pivot value.</p> <p>[lo,s) only contains elements strictly less than pivot [s,f)  contains elements equal to or greater than pivot.</p> <p>Initial conditions are :</p> <p>s, f = 0,0</p> <p>Both invariants are trivially true initially.</p> <p>During execution :</p> <p><pre><code>[---&lt;=pivot----|---&gt;pivot------|---Unexamined---|pivot] \nlo              s               f                    hi \n</code></pre> The algorithm is </p> <pre><code>def partition(arr,lo,hi) :\n    s = lo\n    pivot = arr[hi]\n    # The range might as well be range(lo,hi+1). It would make no difference except one extra redundant comparsion.\n    for f in range(lo,hi) : \n         if arr[f] &lt; pivot : \n              arr[s],arr[f] = arr[f],arr[s] #swap s and f\n              s+=1\n    arr[s],arr[hi] = arr[hi],arr[s]\n    return s      \n</code></pre> <p>When for loop exits, s is positioned at the sorted position of pivot. We swap pivot with s and return s.</p> <pre><code>[ 1,  4,  7,  3,  1,  4 ]\n      s       f             # arr[f] &lt; pivot is True, s and f will be swapped and both will move ahead.\n[ 1,  3,  7,  4,  1,  4 ]    \n          s       f\n[ 1,  3,  1,  4,  7,  4 ]\n              s       f\n[ 1,  3,  1,  4,  7,  4 ]\n                  s       f  # for loop ends\n[ 1,  3,  1,  4,  4,  7 ]\n                  s       f  # FInally Swap s with f\nReturn s \n\n\nReverse sorted array :\n  [ 3, 2, 1 ]\n    s        f \n  [ 1, 2, 3 ]\n    s        f\nreturn s\n\nReverse sorted array with duplicate keys:\n[3, 2 ,1, 1]\n s          f\n\nreturn s \n\nDuplicate keys :\n1  1  1  1 \ns          f #swap s[0] with s[-1]\nreturn s \n</code></pre> <p>The two implementations behave differently when it comes to duplicate keys :</p> <p>The first implementation puts one instance of the pivot value in the LAST sorted position. The second implementation puts one instance of the pivot value in the FIRST sorted position.</p>"},{"location":"Algorithms/iterative/1_array_partitioning/1_two_way_partition/2_Lomuto/#additional-resources","title":"Additional Resources","text":"<p>https://www.cs.virginia.edu/~horton/cs4102/page4/files/06-ch6-sorting.ppt.pdf</p> <p>https://iq.opengenus.org/lomuto-partition-scheme/</p> <p>https://www.stepanovpapers.com/PAM3-partition_notes.pdf</p> <p>https://dlang.org/blog/2020/05/14/lomutos-comeback/</p> <p>https://nicholasvadivelu.com/2021/01/11/array-partition/</p> <p>https://cs-notes.gitbook.io/algorithm-notes/outline/overview-2/quick-sort</p>"},{"location":"Algorithms/iterative/1_array_partitioning/2_three_way_partition/Djikstra/","title":"Index","text":"<p>Coming Soon</p>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/","title":"Quickselect and Quicksort","text":""},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#quickselect","title":"QuickSelect","text":""},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#defining-the-problem","title":"Defining the problem.","text":"<p>Given an array, find the sorted value in non decreasing order at the kth smallest index when indices are counted from zero.</p>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#the-algorithm","title":"The Algorithm","text":"<p>The core of the quickselect algorithm is the partitioning scheme. There are different ways of implementing quickselet based on whether the partitioning scheme puts the pivot in its sorted position or not. Here we will consider only the implementation which uses partition schemes which do, becuase this is simpler and more intuitive.</p> <p>Assume, you have a partitioning scheme which returns some partition index / pivot index s.t. the value at the pivot index is in its sorted position. The quickeselect algorithm makes one recursive call based on the relative position of k to the pivot index. The base case is when the pivot index is k.</p> <p>The algorithm is :</p> <pre><code>def quickselect(arr,lo,hi, k ) :\n    p = partition(arr,lo,hi)\n    if p == k :\n       return arr[k]\n    elif  k&lt; p :\n       return quickselect(arr,lo,p-1,k)\n    else :\n       return quickselect(arr,p+1,hi,k)\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#additional-references","title":"Additional References :","text":"<p>https://en.wikipedia.org/wiki/Selection_algorithm</p>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#quicksort","title":"QuickSort","text":""},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#defining-the-problem_1","title":"Defining the problem.","text":"<p>GIven an array, sort it in non decreasing order.</p>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#the-algorithm_1","title":"The Algorithm","text":"<p>Once you understand partitioning, quickselect and quicksort are just recursive applications of it. In quickselect, we make a single recursive call, while in quicksort, we make two recursive calls to eventually put all elements in their sorted position. Quick Sort can be visualized as a preorder traversal of a binary tree, where in the preorder position, you call the partitioning function and recursively call quicksort on both partitions. The base case is when lo &gt;= hi.</p> <p>Assume, you have a partitioning scheme which returns some partition index / pivot index s.t. the value at the pivot index is in its sorted position.</p> <p>The algorithm is :</p> <pre><code>def quicksort(arr,lo,hi, k ) :\n    if lo &gt;= hi  :\n       return \n    p = partition(arr,lo,hi)\n    quicksort(arr,lo,p-1,k)\n    quicksort(arr,p+1,hi,k)\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/#additional-references_1","title":"Additional References :","text":"<p>https://algs4.cs.princeton.edu/23quicksort/</p>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/quickselect_hoare_two_way_partition_1/","title":"<code>quickselect_hoare_two_way_partition_1.py</code>","text":"<pre><code>from typing import List\nimport random\n\ndef quickselect(arr: List[int],lo: int,hi: int,k : int) -&gt; int :\n    \"\"\"\n    Quickselect using Hoare partition with a weak condition and fixed pivot. \n\n    This is the implementation which you will find in textbooks using do..while style loops which in python becomes while True loops.\n    I prefer avoiding white True loops. \n    It's still using Hoare partition with a weak condition. But the pivot selection is not random.\n    Notice how the performance degrades to O(n^2) for sorted array because the pivot selection is not random.\n    Compare this with next version which uses a random pivot.\n    \"\"\"\n    v = arr[lo]\n    i = lo\n    j = hi+1\n    while True:\n        while True:\n            i += 1\n            if not (i &lt; hi and arr[i] &lt; v):\n                break\n        while True:\n            j -= 1\n            if not (j &gt; lo and arr[j] &gt; v):\n                break\n        if i &gt;= j:\n            break\n        arr[i], arr[j] = arr[j], arr[i]\n    arr[lo], arr[j] = arr[j], arr[lo]\n\n    print(f\"Pivot Value: {v}  ,Partitioned list : {arr}, Partition Index = {j} , le = {lo}, hi = {hi}, k = {1}\")\n    if k -1  == j :\n        print(f\"Returning index {j}\")\n        return nums[j]\n    elif k -1 &gt; j : \n        return quickselect(nums,j+1,hi,k)\n    else :\n        return quickselect(nums,lo,j-1,k)\n\nif __name__ == \"__main__\" :\n    # nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,1,1,1,1,1,1,1,1,1,1,1-2,-5]               # O(nlogn)\n    nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  # O(nlogn)\n    # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]  #degrades to O(n^2)\n    # nums = [24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]  #O(nlogn)\n    print( \n           f\"kth_largest = { quickselect(nums, 0, len(nums)-1 ,23) }\" \n          )\n\n    # nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] # O(nlogn)\n    # print( \n    #        f\"kth_largest = { quickselect(nums, 0, len(nums)-1 ,1) }\" \n    #       )\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/quickselect_hoare_two_way_partition_2/","title":"<code>quickselect_hoare_two_way_partition_2.py</code>","text":"<pre><code>from typing import List\nimport random\n\n\ndef hoare_partition(arr, lo, hi):\n    \"\"\"\n    Entropy Optimal Hoare partition.\n    Produces balanced partitions when there are large number of duplicates.\n    [lo,right] contains elements less than or equal to pivot.\n    (right,hi]  contains elements greater than or equal to pivot.\n    Invariants for the while loop :\n    [lo] has pivot  \n    [lo, left)  &lt;= pivot    #Has values &lt;= pivot\n    (right, hi] &gt;= pivot\n    [pivot|--- &lt;=pivot-----|-----Undetermined-------|---&gt;=pivot----]\n                            left               right\n    After execution of while loop : \n    [pivot|----&lt;=pivot------|-----&gt;=pivot------]\n    lo                  right                  hi\n    [lo,right] &lt;= pivot\n    After Putting pivot in sorted position : \n    [----&lt;=pivot----|pivot|-----&gt;=pivot------]\n    lo               right                  hi\n    Finally, return right.\n    \"\"\"\n    #PIVOT SELECTION\n    #Pick a random pivot index and always keep pivot at index lo\n    #NB:  random.randint(0,0) is 0.\n    pivot_index = random.randint(lo,hi)\n    arr[lo],arr[pivot_index] =  arr[pivot_index],arr[lo]\n    #read pivot value\n    pivot = arr[lo]\n\n    #PARTITIONING\n    #partition [lo+1,hi] ; \n    #NB : when lo == hi , while loop will not be executed\n    left,right = lo+1, hi\n    while left&lt;=right:\n        #Move left ahead if arr[left] is strictly less than pivot value\n        while left &lt;= right and arr[left] &lt; pivot :\n            left+=1\n        #Move right to the left if it is strictly higher than pivot\n        while left &lt;= right  and arr[right] &gt; pivot :\n            right-=1\n        #Swap left and right and move pointers\n        #If both values are equal to pivot this will do a swap,move pointers and effectively leave pivot values where they are. \n        if left &lt;=  right :\n            arr[left], arr[right] = arr[right], arr[left]\n            right-=1\n            left+=1\n    #Put pivot in sorted position\n    arr[lo], arr[right] = arr[right], arr[lo]\n    return right\n\ndef quickselect(arr: List[int],lo: int,hi: int,k : int) -&gt; int :\n    \"\"\"\n    Quicselect using Hoare partition with weak condition and random pivot.\n    Return vlaue at Kth SMALLEST Index,\n    Returns the non decreasingly sorted value at kth Index with indices starting from lo. [lo ,hi] is inclusive.\n    This uses Hoare's partition scheme with a weak condition and which also puts pivot in its sorted position.\n    \"\"\" \n    pivot_index = hoare_partition(arr,lo,hi)\n    print(f\"Pivot Value: {arr[pivot_index]}  ,Partitioned list : {arr}, Partition Index = {pivot_index} , le = {lo}, hi = {hi}, k = {k}\")\n    if k == pivot_index :\n        return arr[k]\n    if k &lt; pivot_index :\n        return quickselect(arr,lo, pivot_index-1,k)\n    elif k &gt; pivot_index :  \n         return quickselect(arr,pivot_index+1,hi,k)\n\n\n\nif __name__ == \"__main__\" :\n    # nums = [5,2,1,1,1,1,1,1,1,1,1,5,5,-3,1,1,1,1,1,1,1,1,1,1,1-2,-5]                 # O(nlogn)\n    # nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  # Close to O(nlogn)\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]  #STill close to O(nlogn) . WIthout random pivot degrades to O(n^2)\n    # nums = [24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]  #O(nlogn)\n    print( \n           f\"kth_largest = { quickselect(nums, 0, len(nums)-1 ,23) }\" \n          )\n</code></pre>"},{"location":"Algorithms/iterative/1_array_partitioning/3_quick_select/quicksort_hoare_two_way_partition_1/","title":"<code>quicksort_hoare_two_way_partition_1.py</code>","text":"<pre><code>from typing import List\nimport random\n\n\ndef hoare_partition(arr, lo, hi):\n    \"\"\"\n    Entropy Optimal Hoare partition.\n    Produces balanced partitions when there are large number of duplicates.\n    [lo,right] contains elements less than or equal to pivot.\n    (right,hi]  contains elements greater than or equal to pivot.\n    Invariants for the while loop :\n    [lo] has pivot  \n    [lo, left)  &lt;= pivot    #Has values &lt;= pivot\n    (right, hi] &gt;= pivot\n    [pivot|--- &lt;=pivot-----|-----Undetermined-------|---&gt;=pivot----]\n                            left               right\n    After execution of while loop : \n    [pivot|----&lt;=pivot------|-----&gt;=pivot------]\n    lo                  right                  hi\n    [lo,right] &lt;= pivot\n    After Putting pivot in sorted position : \n    [----&lt;=pivot----|pivot|-----&gt;=pivot------]\n    lo               right                  hi\n    Finally, return right.\n    \"\"\"\n    #PIVOT SELECTION\n    #Pick a random pivot index and always keep pivot at index lo\n    #NB:  random.randint(0,0) is 0.\n    pivot_index = random.randint(lo,hi)\n    arr[lo],arr[pivot_index] =  arr[pivot_index],arr[lo]\n    #read pivot value\n    pivot = arr[lo]\n\n    #PARTITIONING\n    #partition [lo+1,hi] ; \n    #NB : when lo == hi , while loop will not be executed\n    left,right = lo+1, hi\n    while left&lt;=right:\n        #Move left ahead if arr[left] is strictly less than pivot value\n        while left &lt;= right and arr[left] &lt; pivot :\n            left+=1\n        #Move right to the left if it is strictly higher than pivot\n        while left &lt;= right  and arr[right] &gt; pivot :\n            right-=1\n        #Swap left and right and move pointers\n        #If both values are equal to pivot this will do a swap,move pointers and effectively leave pivot values where they are. \n        if left &lt;=  right :\n            arr[left], arr[right] = arr[right], arr[left]\n            right-=1\n            left+=1\n    #Put pivot in sorted position\n    arr[lo], arr[right] = arr[right], arr[lo]\n    return right\n\ndef quicksort(arr: List[int],lo: int,hi: int) -&gt; int :\n    \"\"\"\n    Quicksort using Hoare partition with weak condition and random pivot.\n    This uses Hoare's partition scheme with a weak condition and which also puts pivot in its sorted position.\n    \"\"\" \n    if lo &gt;= hi :\n        return\n    p = hoare_partition(arr,lo,hi)\n    quicksort(arr,lo, p-1)\n    quicksort(arr,p+1,hi)\n\n\n\nif __name__ == \"__main__\" :\n    nums = [24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]\n    quicksort(nums,0,len(nums)-1)\n    print (nums)\n</code></pre>"},{"location":"Algorithms/iterative/2_binary_search/","title":"Index","text":"<p>Coming soon</p>"},{"location":"Algorithms/iterative/2_binary_search/problems/median_of_two_sorted_arrays/LC_4__median_of_two_sorted_arrays/","title":"What is the data?","text":"<p>nums1 = [1,2], nums2 = [3,4]</p> <p>Two sorted arrays.</p>"},{"location":"Algorithms/iterative/2_binary_search/problems/median_of_two_sorted_arrays/LC_4__median_of_two_sorted_arrays/#what-is-being-asked","title":"What is being asked?","text":"<p>To find the median in logarithmic time.</p>"},{"location":"Algorithms/iterative/2_binary_search/problems/median_of_two_sorted_arrays/LC_4__median_of_two_sorted_arrays/#thoughts","title":"Thoughts","text":"<p>What is a median</p> <p>Consider : <pre><code>[1 2 |3 4]  #right partition is inclusive \n</code></pre> If we partition an even lengthed sorted array such that the left and right partitions are of equal size.</p> <p>The median is ( max(left partition) + min(right partition)  ) / 2</p> <p>If the array is odd lengthed : <pre><code>[1 2 3 4 5]\n     *\n</code></pre> We can consider the middle element to belong to both partitions. In which case <pre><code>[1 2 3 4 5]\n     *\n</code></pre></p> <p>The middle element IS the median i.e. index len(arr)//2</p> <p>We can always find partitions on A and B such that elements to the left of both partitions are less than elements to their right.</p> <pre><code>Example 1: \nB [ 1, 2, |6, 7]  # right pertition is inclusive\nA  [  5, |10  ]\n\n1,2,5  &lt; 6,7,10\n</code></pre> <pre><code>Example 2 :\nB [ |5, 6, 7, 8, 9 ] # consider left out of bounds position to be -inf and right out of bounds position to be +inf\n\nA [ 1, 2, 3, 4| ]\n\n1,2,3,4 &lt; 5,6,7,8,9\n</code></pre> <p>If we find the correct partitions like this, we can calculate the mean,</p> <p>The first question is how should we define the partitions?</p> <p>partition_a + partition_b = (m+n+1) //2 OR partition_a + partition_b = (m+n) // 2 </p> <p>let len(A) =m and len(B) = n </p> <p>FOR ODD LENGTHED ARRAY :</p> <pre><code>B  [1]   ; #IFF partition_b = (m+n +1 )//2 - partition_a  = 2//2 -0 = 1 But *IFF partition_b =  (m+n)//2 - partition_a =  1//2 -0 = 0-0 = 0 \n   *0 #1  \nA  [ ]   ; partition_a = (0+ 0)//2 =0 \n    0\n</code></pre> <p>If we say that partition_x + partition_y = (m+n)//2 then median is in the right partition in case of odd lengthed array.</p> <p>If we say that partition_x + partition_y = (m+n+1)//2 then median is in the left partition in case of odd lenghted array.</p> <p>It makes no difference for arrays where m+n is even. <pre><code>B [1 2]   ; #IFF partition_b = (m+n+1)//2 - partition_a  = 5//2 - 1 = 2- 1 = 1 and *IFF partition_b = (m+n)//2 - partition_a = 4//2 -1 = 1\n    #*1\nA [1 2]   ; partition_a = (0 + 2) // 2 = 1\n</code></pre></p> <p>Lets pick one convention : </p> <p>partition_a + partition_b = (m+n) //2</p> <p>Now for the binary search:</p> <p>It makes sense to binary search on the smaller array. Lets call this array A and the partition on it,  partition_a.</p> <p>For each partition_a we ask is left_b &gt; partition_a. If this is TRUE, then partition_a cannot be the pivot and needs to be moved right i.e. made larger.</p> <pre><code> INIT:         \n [ 1  3  4  5   6  ]\n  [ 2  6  7   8   ] \n    lo          hi\nITER 1:\n [1  3  4  5  6  ]\n        *            #left_b is 3.\n  [ 2 6 7  8 ]  \n   lo   *            #3 &gt; 7 is F; this could be the right partition_a ; hi = mid\n       F/hi\nITER 2 :\n [1  3  4  5  6  ]\n           *\n  [ 2  6 7  8 ]\n   lo  *           #4&gt; 6 is F  ; this could be partition_a hi = mid            \n      F/hi\nITER 3 :\n [1  3  4  5  6  ]\n              *\n  [ 2    6  7  8 ]\n    *              #5&gt;2 T; This cannot be the right partition_a ;\n    T/lo hi        #lo = mid+1  ; loop exits in next iteration\nITER 5 :\n[2     6   7   8]\n       *\n       F/lo,hi\nlo = hi = 1 and loop exits\n</code></pre> <p>Binary search will converge on first false value. <pre><code>   [1    3    4     |5    6  ]\n     [2     |6    7    8]\n      T     F    F    F\n</code></pre></p> <p>In our binary search we need a function move_right which simply returns left_b &gt; right_a</p> <p>Thats it. Once , we have the right partition, calculate mean:</p> <p>If (m+n) is odd : return min(right_a, right_b)</p> <p>If (m+n) is even : return (max(left_a, left_b) + min(right_a, right_b)) /2 </p>"},{"location":"Algorithms/iterative/2_binary_search/problems/median_of_two_sorted_arrays/LC_4__median_of_two_sorted_arrays/#code","title":"Code","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:\n        # A is always the smaller array\n        A, B = nums1, nums2 \n        if len(A) &gt; len(B) :\n            A , B = B, A\n\n        #measure their lengths    \n        m,n = len(A), len(B)\n\n        def find_partition_b(partition_a) : \n            return (m+n)//2 - partition_a\n\n        def get_left(partition,array) :\n            return float('-inf') if (partition-1 )&lt;0 else array[partition-1]\n\n        def get_right(partition,array) :\n            return float('inf') if (partition)&gt;= len(array) else array[partition]\n\n        def move_right(partition_a) : \n            partition_b = find_partition_b(partition_a)\n            left_b = get_left(partition_b,B)\n            right_a = get_right(partition_a,A)\n            return left_b &gt; right_a\n\n        #binary search to find the correct partition_a\n        lo, hi  = 0 , len(A)\n        while lo &lt; hi :\n            partition_a = (lo +hi) // 2\n            if move_right(partition_a) :\n                lo = partition_a+1\n            else :\n                hi = partition_a\n\n        #lo and hi have converged on the correct partition_a \n        partition_a,partition_b   = lo, find_partition_b(lo)\n        right_a = get_right(partition_a,A)\n        right_b = get_right(partition_b,B)\n\n        #combined array length is odd\n        if (m+n) % 2 == 1 :\n            return min(right_a,right_b)\n\n        #combined array length is even    \n        left_a = get_left(partition_a,A)\n        left_b = get_left(partition_b,B)\n        return ( max(left_a,left_b) + min(right_a,right_b) ) / 2        \n</code></pre>"},{"location":"Algorithms/iterative/3_Sorting/properties_of_comparison_based_sorting_algorithms/","title":"Properties of Comparison Based Sorting Algorithms","text":""},{"location":"Algorithms/iterative/3_Sorting/properties_of_comparison_based_sorting_algorithms/#quicksort","title":"Quicksort","text":"<p>Not Stable, Not adaptive. In-Place. O(NlogN) Average Case. </p> <p>Pivot Selection and partitioning schemes affect Complexity in a major way. </p> <p>Pivot Selection : Fixed at hi or lo (worst), random (Good enough in practicw), Median of three, etc. </p> <p>Partitoning  :  Two way partitioning ( Eg. Hoare Partitioning with weak condition) , Three way partitioning (Eg : Djikstra) , Dual Pivot partitioning.  </p> <p>Quicksort is a highly reaearched algorithm and there are many variations and derivatives. It is more like a family of algorithms. </p> <p>Can degrade to O(n^2) in cases for duplicate keys and sorted inputs, depending on pivot selection and partitioning scheme.</p> <p>Important thing to note, The most common partitioning scheme found on the internet (Lomuto parition) performs more swaps than Hoare partition with a weak condition. Also, it degrades to O(n^2) when all elements are the same ( Hoare partition with a strict condition will also degrade to O(n^2) for duplicate keys).   </p> <p>Lomuto was popularized by Bentley in the book Programming Pearls because he found Hoare difficult and unintuitve. One advantage to note: because Lomuto uses two forward iterators, it can be used on singly linked lists.</p>"},{"location":"Algorithms/iterative/3_Sorting/properties_of_comparison_based_sorting_algorithms/#mergesort","title":"Mergesort","text":"<p>In-place. Stable. Not adaptive. Not In-place (Needs extra space) . O(NlogN) worst case. Can be combined with Insertion sort for small subproblem sizes.</p>"},{"location":"Algorithms/iterative/3_Sorting/properties_of_comparison_based_sorting_algorithms/#bubble-sort","title":"Bubble Sort","text":"<p>Stable. Can be made adaptive (just add a flag to tell if a swap has occurred. If not exit early). </p> <p>Invariant for inner loop</p> <p>[ | ]   j <pre><code>def optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        swapped = False  # Flag for no swaps in a pass\n        for j in range(n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True  # Swap occurred\n        if not swapped:\n            return  # Already sorted, no more passes needed\n    return arr\n</code></pre></p>"},{"location":"Algorithms/iterative/3_Sorting/properties_of_comparison_based_sorting_algorithms/#insertion-sort","title":"Insertion Sort","text":"<p>Quadratic. In-place. Stable. Adaptive.</p> <pre><code>def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j &gt;= 0 and key &lt; arr[j]:\n            arr[j+1] = arr[j]\n            j -= 1\n        arr[j+1] = key\n</code></pre> <p>This is quite similar to optimized bubble sort except that in bubble sort,the sort element (maximimum) is bubbled into unsorted section while in insertion sort, the sort element (minimum) is bubbled into the sorted section. </p> <p>Insertion sort is ONLINE. Each new element can be put in its sorted place as it is received.</p> <p>Shell Sort is a faster variation of Insertion sort (named after D.L. Shell who invented it). It uses insertion sort on periodic subarrays.</p> <p>Alse see :  https://stackoverflow.com/questions/47712062/how-to-distinguish-online-and-offline-sorting-algorithms</p> <p>https://cs.stackexchange.com/questions/55012/what-is-the-fastest-online-sorting-algorithm</p>"},{"location":"Algorithms/iterative/3_Sorting/properties_of_comparison_based_sorting_algorithms/#selection-sort","title":"Selection Sort","text":"<p>Quadratic. In-Place. Not Stable. Not Adaptive. </p> <p>Only advantage over insertion sort : performs less swaps than insertion sort.</p>"},{"location":"Algorithms/iterative/3_Sorting/properties_of_comparison_based_sorting_algorithms/#additional-references","title":"Additional References","text":"<p>https://www.toptal.com/developers/sorting-algorithms</p>"},{"location":"Algorithms/recursive/1_basics/Introduction/","title":"Basic Recursion","text":"<p>Understand what happens when you \"do\" something before the recursive call (preorder position) or after the recursive call (postorder position). Debug this and see what is happening on the stack and how function calls are stacked and unwound.</p>"},{"location":"Algorithms/recursive/1_basics/recursion_print_numbers_1/","title":"<code>recursion_print_numbers_1.py</code>","text":"<pre><code>\"\"\"\nPrint Numbers from i to 5.\n\"\"\"\n\ndef print_nums(i) :\n    if i &gt; 5 :\n        return\n\n    #preorder position\n    print(i)\n    #recursive call\n    print_nums(i+1)\n\n\"\"\"\nPrint Numbers from i to 5 in reverse order\n\"\"\"\n\ndef print_nums_backwards(i) :\n    if i &gt; 5 :\n        return\n\n    #recursive call\n    print_nums_backwards(i+1)\n    #postorder position\n    print(i)\n\n\nprint_nums(1)\nprint_nums_backwards(1)\n</code></pre>"},{"location":"Algorithms/recursive/1_basics/recursion_print_numbers_2/","title":"<code>recursion_print_numbers_2.py</code>","text":"<pre><code>\"\"\"\nPrint Numbers from 1 to n .\n\"\"\"\n\ndef print_nums_1_to_n(n) :\n    if n == 0 :\n        return\n    print_nums_1_to_n(n-1)\n    print(n)\n\n#print  1 to n\nprint_nums_1_to_n(5)\n\n\n\"\"\"\nPrint Numbers from n to 1 .\n\"\"\"\n\ndef print_nums_n_to_1(n) :\n    #base cases\n    if n == 0 :\n        return\n\n    print(n)\n    print_nums_n_to_1(n-1)\n\n\nprint_nums_n_to_1(5)\n</code></pre>"},{"location":"Algorithms/recursive/1_basics/recursion_print_numbers_3/","title":"<code>recursion_print_numbers_3.py</code>","text":"<pre><code>\"\"\"\nPrint Numbers n to 1 and then 1 to n\n\"\"\" \ndef print_nums(n) :\n    if n == 0 :\n        print(\"Base Case Hit.\")\n        return\n    #preorder position\n    print(f\"Preorder : {n}\")\n    #recursive call\n    print_nums(n-1)\n    #postorder position\n    print(f\"Postorder : {n}\")\n\n\nprint_nums(5)\n</code></pre>"},{"location":"Algorithms/recursive/2_backtracking/Introduction/","title":"Backtracking","text":"<p>Backtracking seems and difficult to learn, because there are so many different ways of doing the same thing.</p> <p>Here, we solve the same problem in many different ways only to see the possibilities.</p>"},{"location":"Algorithms/recursive/2_backtracking/generate_nbit_binary_numbers_1/","title":"<code>generate_nbit_binary_numbers_1.py</code>","text":"<pre><code>\"\"\"\nRecursive Decomposition\n\"\"\"\ndef generate(n) : \n    \"\"\"\n    Eg : For n = 3 , We have 3 spots each of which can be filled with 0 or 1.\n\n    -    -   -\n    1/0\n         1/0  \n             1/0\n\n    1 1 1\n    1 1 0\n    1 0 1\n    1 0 0\n    0 1 1\n    0 1 0\n    0 0 1\n    0 0 0 \n    \"\"\"\n    if n == 0 : \n        return [\"\"]\n\n    l = [ \"1\" + _ for _ in  generate(n-1) ] \n    r = [ \"0\" + _ for _ in  generate(n-1) ]\n\n    return l + r  \n\nprint(generate(3))\n</code></pre>"},{"location":"Algorithms/recursive/2_backtracking/generate_nbit_binary_numbers_2/","title":"<code>generate_nbit_binary_numbers_2.py</code>","text":"<pre><code>\"\"\"\nBacktracking -  Path is an array. Make choices ( Pick 0 and 1) explicitly.\n\"\"\"\ndef generate(n) : \n    \"\"\"\n    Eg : For n = 3 , We have 3 spots each of which can be filled with 0 or 1. \n\n    -    -   -\n    1/0\n         1/0  \n             1/0\n\n    1 1 1\n    1 1 0\n    1 0 1\n    1 0 0\n    0 1 1\n    0 1 0\n    0 0 1\n    0 0 0 \n    \"\"\"\n\n    path = [None] * n\n    res = []\n\n    #choose  0 or 1 at idx\n    def backtrack(idx) : \n        if idx == len(path): \n            res.append(\"\".join(path[:]))\n            return \n        path[idx] = '0'\n        backtrack(idx+1)\n        #Here we dont care if path[idx] overwritten\n        #Undo of choice is implicit\n        path[idx] = '1'\n        backtrack(idx+1)\n        #Undo of choice is implicit\n\n    backtrack(0)\n    return res\n\nprint(generate(4))\n</code></pre>"},{"location":"Algorithms/recursive/2_backtracking/generate_nbit_binary_numbers_3/","title":"<code>generate_nbit_binary_numbers_3.py</code>","text":"<pre><code>\"\"\"\nRecursive Decomposition\n\"\"\"\ndef generate(n) : \n    \"\"\"\n    -    -   -\n    1/0\n         1/0  \n             1/0\n\n    1 1 1\n    1 1 0\n    1 0 1\n    1 0 0\n    0 1 1\n    0 1 0\n    0 0 1\n    0 0 0 \n    \"\"\"\n\n    path = [] #We will treat this as a stack in this implementation\n    res = []\n\n    #choose  0 or 1 at idx\n    def backtrack(idx) : \n        if idx == n: \n            res.append(\"\".join(path[:]))\n            return \n        #Pick 0\n        path.append('0')\n        #Explore 0 \n        backtrack(idx+1)\n        #Undo 0 \n        path.pop()\n        #Pick 1\n        path.append('1')\n        #Explore 1\n        backtrack(idx+1)\n        #Undo 1\n        path.pop()\n\n    backtrack(0)\n    return res\n\nprint(generate(3))\n</code></pre>"},{"location":"Algorithms/recursive/2_backtracking/generate_nbit_binary_numbers_4/","title":"<code>generate_nbit_binary_numbers_4.py</code>","text":"<pre><code>\"\"\"\nRecursive Decomposition\n\"\"\"\ndef generate(n) : \n    \"\"\"\n    Eg : For n = 3 , We have 3 spots each of which can be filled with 0 or 1. \n\n    -    -   -\n    1/0\n         1/0  \n             1/0\n\n    1 1 1\n    1 1 0\n    1 0 1\n    1 0 0\n    0 1 1\n    0 1 0\n    0 0 1\n    0 0 0 \n    \"\"\"\n\n    path = [None] * n\n    res = []\n\n    #choose  0 or 1 at idx\n    def backtrack(idx) : \n        if idx == len(path): \n            res.append(\"\".join(path[:]))\n            return \n        for choice in ['0','1'] : \n            path[idx] = choice\n            backtrack(idx+1)\n            #Here we dont care if path[idx] overwritten,\n            #Undo of choice is implicit\n\n    backtrack(0)\n    return res\n\nprint(generate(3))\n</code></pre>"},{"location":"Algorithms/recursive/2_backtracking/generate_nbit_binary_numbers_5/","title":"<code>generate_nbit_binary_numbers_5.py</code>","text":"<pre><code>\"\"\"\nRecursive Decomposition\n\"\"\"\ndef generate(n) : \n    \"\"\"\n    Eg : For n = 3 , We have 3 spots each of which can be filled with 0 or 1. \n\n    -    -   -\n    1/0\n         1/0  \n             1/0\n\n    1 1 1\n    1 1 0\n    1 0 1\n    1 0 0\n    0 1 1\n    0 1 0\n    0 0 1\n    0 0 0 \n    \"\"\"\n\n    path = []  # We will treat this like a stack in this implementation\n    res = []\n\n    #choose  0 or 1 at idx\n    def backtrack(idx) : \n        if idx == n: \n            res.append(\"\".join(path[:]))\n            return \n        for choice in ['0','1'] : \n            #Make a choice \n            path.append(choice)\n            #Explore this choice\n            backtrack(idx+1)\n            #Undo this choice before making next choice. Undo of choice is explicit\n            path.pop()\n\n    backtrack(0)\n    return res\n\nprint(generate(3))\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/test/","title":"Building Serverless ETL Pipelines on AWS","text":"<p>In this post, I'll share my experience building a serverless ETL pipeline to extract and map medical entities using various AWS services including Lambda, SNS, Textract, Translate, Comprehend Medical, Glue, and Athena.</p>","tags":["tag1","tag2"]},{"location":"blog/test/#the-challenge","title":"The Challenge","text":"<p>Working at Genentech, I faced the challenge of extracting medical entities from multilingual clinical notes that came in various formats including handwritten images, PDFs, and DOCX files. These entities needed to be mapped to standardized ICD-10 codes for analysis.</p>","tags":["tag1","tag2"]},{"location":"blog/test/#architecture-overview","title":"Architecture Overview","text":"<p>Our solution leveraged a serverless architecture with these key components:</p> <ol> <li>Document Ingestion: AWS S3 for storage with event triggers</li> <li>Text Extraction: AWS Textract for converting documents to machine-readable text</li> <li>Translation: AWS Translate for handling multilingual content</li> <li>Entity Recognition: AWS Comprehend Medical for identifying medical terms</li> <li>Code Mapping: Custom Lambda function to map to ICD-10 codes</li> <li>Data Storage: Processed results stored in S3 and cataloged in Glue</li> <li>Analysis: Athena for SQL-based querying of the processed data</li> </ol>","tags":["tag1","tag2"]},{"location":"blog/test/#implementation-details","title":"Implementation Details","text":"<p>[Content continues with technical implementation details]</p>","tags":["tag1","tag2"]},{"location":"blog/test/#benefits-and-results","title":"Benefits and Results","text":"<p>The serverless approach provided several advantages:</p> <ol> <li>Cost Efficiency: Pay-per-use model reduced operational costs by 40%</li> <li>Scalability: Automatic scaling handled varying document loads</li> <li>Maintenance: Reduced operational overhead compared to EC2-based solutions</li> <li>Accuracy: Achieved 92% accuracy in entity recognition and mapping</li> </ol>","tags":["tag1","tag2"]},{"location":"blog/test/#lessons-learned","title":"Lessons Learned","text":"<p>[Content continues with lessons learned and best practices]</p>","tags":["tag1","tag2"]},{"location":"blog/test/#conclusion","title":"Conclusion","text":"<p>Serverless ETL pipelines offer significant advantages for processing unstructured medical data at scale. By leveraging AWS's managed services, we created a solution that was both cost-effective and powerful.</p> <p>Feel free to reach out if you have questions about implementing similar solutions in your organization!</p>","tags":["tag1","tag2"]},{"location":"resources/blogs/","title":"Blogs","text":""},{"location":"resources/blogs/#data-engineering","title":"Data Engineering","text":"<p>https://asrathore08.medium.com/</p>"},{"location":"resources/blogs/#sql","title":"SQL","text":"<p>https://www.sommarskog.se/#largeones</p>"},{"location":"resources/blogs/#ai-engineering","title":"AI Engineering","text":"<p>https://amitness.com/</p>"},{"location":"resources/playgrounds/","title":"Playgrounds","text":"<p>Playgrounds and learning platforms.</p>"},{"location":"resources/playgrounds/#k8s-linux-containers","title":"K8S/ Linux / Containers","text":"<p>https://labs.iximiuz.com/</p>"},{"location":"resources/playgrounds/#sql","title":"SQL","text":"<p>https://mode.com/sql-tutorial/sql-in-mode</p>"},{"location":"resources/playgrounds/#spark","title":"Spark","text":"<p>https://www.sparkplayground.com/</p>"},{"location":"resources/playgrounds/#mlai","title":"ML/AI","text":"<p>https://afaik.io/</p>"},{"location":"resources/posts/","title":"Posts","text":""},{"location":"resources/posts/#sql-optimization","title":"SQL Optimization","text":"<p>https://blog.devgenius.io/mastering-explain-analyze-become-a-db-query-optimization-pro-cf1e52bcb92e</p> <p>https://planetscale.com/blog/what-is-n-1-query-problem-and-how-to-solve-it (N+1 Problem)</p>"},{"location":"resources/posts/#dataframe-projects","title":"DataFrame Projects","text":"<p>https://news.ycombinator.com/item?id=34578324 ( SQL vs DF )</p> <p>https://docs.dask.org/en/stable/10-minutes-to-dask.html</p> <p>https://docs.coiled.io/blog/tpch.html</p> <p>https://github.com/dask/dask-expr/issues/1065 (Join Order Optimization)</p> <p>https://github.com/coiled/benchmarks/issues/1515 </p>"},{"location":"resources/posts/#airflow","title":"Airflow","text":"<p>https://medium.com/nerd-for-tech/airflow-features-callback-trigger-clsuter-policy-cc7f8022e7d3</p>"},{"location":"resources/posts/#productivity","title":"Productivity","text":"<p>https://borretti.me/article/depth-first-procrastination</p>"},{"location":"resources/posts/#interviewing","title":"Interviewing","text":"<p>https://www.tik.dev/blog/tech-interviews</p>"},{"location":"resources/posts/#mkdocs","title":"MkDocs","text":"<p>https://whliao.me/blog/material-for-mkdocs-advanced-customization/</p>"},{"location":"resources/posts/#other","title":"Other","text":"<p>https://planetscale.com/blog/what-is-n-1-query-problem-and-how-to-solve-it</p>"},{"location":"resources/resources/","title":"Resources","text":""},{"location":"resources/resources/#data-engineering","title":"Data Engineering","text":"<p>https://datatalks.club/</p>"},{"location":"resources/resources/#ai-engineering","title":"AI Engineering","text":"<p>https://cookbook.openai.com/</p>"},{"location":"resources/resources/#k8s-linux-containers","title":"K8S/ Linux / Containers","text":"<p>https://labs.iximiuz.com/</p>"},{"location":"resources/resources/#sql","title":"SQL","text":"<p>https://mode.com/sql-tutorial/sql-in-mode</p>"},{"location":"resources/resources/#mkdocs","title":"MkDocs","text":"<p>https://whliao.me/blog/material-for-mkdocs-advanced-customization/</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/aws/","title":"AWS","text":""},{"location":"blog/category/etl/","title":"ETL","text":""},{"location":"blog/category/serverless/","title":"Serverless","text":""}]}