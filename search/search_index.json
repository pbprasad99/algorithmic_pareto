{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"algorithmic_pareto","text":"<p>[WIP]  Algorithms and Data Structures - The Pareto Set</p> <p>The absolute basics to master.</p>"},{"location":"#philosophy","title":"philosophy","text":"<p>Broadly, I classify any algorithm or data structure into recursive or iterative. Of course, this is not a strict demarcation, but only in terms of the usual implementations.</p> <p>As for data structures, there are two fundamental types in terms of how they are stored : contiguous storage (arrays, dynamic arrays) and linked storage (linked lists, trees, graphs) </p>"},{"location":"#mental-models","title":"mental models","text":"<p>To effectively use a concept, it helps greatly to have the right mental model which allows you to use it in a consistent manner.</p> <p>For example, understanding and thinking of binary search in terms of bisect left and bisect right makes it easy to actually use it in a consistent manner.</p> <p>Another example, for array partitioning, just thinking of and  defining the loop invariant correctly is key. </p> <p>My effort is always to develop the correct understanding and mental model for any concept.</p>"},{"location":"#call-a-thing-by-its-right-name","title":"call a thing by its right name","text":"<p>Just knowing the name of a thing is very powerful.  Know the name of the problem and know the name of the algorithm.</p>"},{"location":"#index","title":"index","text":"<ul> <li>iterative</li> <li>1_array_partitioning<ul> <li>1_two_way_partition</li> <li>1_Hoare</li> <li>2_Lomuto</li> <li>2_three_way_partition</li> <li>Djikstra</li> <li>3_quick_select</li> </ul> </li> <li>2_binary_search<ul> <li>problems</li> <li>median_of_two_sorted_arrays</li> </ul> </li> <li>recursive</li> <li>1)basicsbasics)</li> <li>2)backtrackingbacktracking)</li> </ul>"},{"location":"#algorithm-categories","title":"Algorithm Categories","text":"<p>This repository contains implementations and explanations of various algorithms categorized by approach:</p> <ul> <li>Iterative: Algorithms that use loops and iterations</li> <li>Recursive: Algorithms that call themselves to solve subproblems</li> <li>Dynamic Programming: Algorithms that break down problems into simpler subproblems</li> <li>Greedy: Algorithms that make locally optimal choices at each step</li> </ul>"},{"location":"#how-to-use-this-resource","title":"How to Use This Resource","text":"<p>Navigate through the sections to find detailed explanations, implementations, and complexity analysis for each algorithm.</p>"},{"location":"assets/","title":"Assets","text":""},{"location":"assets/#sections","title":"Sections","text":"<ul> <li>Css</li> </ul>"},{"location":"assets/css/","title":"Css","text":""},{"location":"assets/images/","title":"Images","text":""},{"location":"iterative/","title":"Iterative","text":""},{"location":"iterative/#sections","title":"Sections","text":"<ul> <li>1 Array Partitioning</li> <li>2 Binary Search</li> </ul>"},{"location":"iterative/1_array_partitioning/","title":"1 Array Partitioning","text":""},{"location":"iterative/1_array_partitioning/#topics","title":"Topics","text":"<ul> <li>Properties Of Comparison Based Sorting Algorithms</li> </ul>"},{"location":"iterative/1_array_partitioning/properties_of_comparison_based_sorting_algorithms/","title":"Quicksort","text":"<p>Not Stable, Not adaptive. In-Place. O(NlogN) Average Case. </p> <p>Pivot Selection and partitioning schemes affect Complexity in a major way. </p> <p>Pivot Selection : Fixed at hi or lo (worst), random (Good enough in practicw), Median of three, etc. </p> <p>Partitoning  :  Two way partitioning ( Eg. Hoare Partitioning with weak condition) , Three way partitioning (Eg : Djikstra) , Dual Pivot partitioning.  </p> <p>Quicksort is a highly reaearched algorithm and there are many variations and derivatives. It is more like a family of algorithms. </p> <p>Can degrade to O(n^2) in cases for duplicate keys and sorted inputs, depending on pivot selection and partitioning scheme.</p> <p>Important thing to note, The most common partitioning scheme found on the internet (Lomuto parition) performs more swaps than Hoare partition with a weak condition. Also, it degrades to O(n^2) when all elements are the same ( Hoare partition with a strict condition will also degrade to O(n^2) for duplicate keys).   </p> <p>Lomuto was popularized by Bentley in the book Programming Pearls because he found Hoare difficult and unintuitve. One advantage to note: because Lomuto uses two forward iterators, it can be used on singly linked lists.</p>"},{"location":"iterative/1_array_partitioning/properties_of_comparison_based_sorting_algorithms/#mergesort","title":"Mergesort","text":"<p>Quadratic. In-place. Stable. Not adaptive. Not In-place (Needs extra space) Can be combined with Insertion sort for small subproblem sizes.</p>"},{"location":"iterative/1_array_partitioning/properties_of_comparison_based_sorting_algorithms/#bubble-sort","title":"Bubble Sort","text":"<p>Stable. Can be made adaptive (just add a flag to tell if a swap has occurred. If not exit early). </p> <p>Invariant for inner loop</p> <p>[ | ]   j <pre><code>def optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        swapped = False  # Flag for no swaps in a pass\n        for j in range(n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True  # Swap occurred\n        if not swapped:\n            return  # Already sorted, no more passes needed\n    return arr\n</code></pre></p>"},{"location":"iterative/1_array_partitioning/properties_of_comparison_based_sorting_algorithms/#insertion-sort","title":"Insertion Sort","text":"<p>Quadratic. In-place. Stable. Adaptive.</p> <pre><code>def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j &gt;= 0 and key &lt; arr[j]:\n            arr[j+1] = arr[j]\n            j -= 1\n        arr[j+1] = key\n</code></pre> <p>This is quite similar to optimized bubble sort except that in bubble sort,the sort element (maximimum) is bubbled into unsorted section while in insertion sort, the sort element (minimum) is bubbled into the sorted section. </p> <p>Insertion sort is ONLINE. Each new element can be put in its sorted place as it is received.</p> <p>Shell Sort is a faster variation of Insertion sort (named after D.L. Shell who invented it). It uses insertion sort on periodic subarrays.</p> <p>Alse see :  https://stackoverflow.com/questions/47712062/how-to-distinguish-online-and-offline-sorting-algorithms</p> <p>https://cs.stackexchange.com/questions/55012/what-is-the-fastest-online-sorting-algorithm</p>"},{"location":"iterative/1_array_partitioning/properties_of_comparison_based_sorting_algorithms/#selection-sort","title":"Selection Sort","text":"<p>Quadratic. In-Place. Not Stable. Not Adaptive. </p> <p>Only advantage over insertion sort : performs less swaps than insertion sort.</p>"},{"location":"iterative/1_array_partitioning/properties_of_comparison_based_sorting_algorithms/#additional-references","title":"Additional References","text":"<p>https://www.toptal.com/developers/sorting-algorithms</p>"},{"location":"iterative/2_binary_search/","title":"2 Binary Search","text":""},{"location":"iterative/2_binary_search/#sections","title":"Sections","text":"<ul> <li>Problems</li> </ul>"},{"location":"iterative/2_binary_search/problems/","title":"Problems","text":""},{"location":"iterative/2_binary_search/problems/#sections","title":"Sections","text":"<ul> <li>Median Of Two Sorted Arrays</li> </ul>"},{"location":"iterative/2_binary_search/problems/median_of_two_sorted_arrays/","title":"Median Of Two Sorted Arrays","text":""},{"location":"iterative/2_binary_search/problems/median_of_two_sorted_arrays/#topics","title":"Topics","text":"<ul> <li>Lc 4  Median Of Two Sorted Arrays</li> </ul>"},{"location":"iterative/2_binary_search/problems/median_of_two_sorted_arrays/LC_4__median_of_two_sorted_arrays/","title":"Lc 4  Median Of Two Sorted Arrays","text":"<p>What is the data? </p> <p>nums1 = [1,2], nums2 = [3,4]</p> <p>Two sorted arrays.</p> <p>What is being asked?</p> <p>To find the median in logarithmic time.</p>"},{"location":"iterative/2_binary_search/problems/median_of_two_sorted_arrays/LC_4__median_of_two_sorted_arrays/#thoughts","title":"Thoughts","text":"<p>What is a median</p> <p>Consider : <pre><code>[1 2 |3 4]  #right partition is inclusive \n</code></pre> If we partition an even lengthed sorted array such that the left and right partitions are of equal size.</p> <p>The median is ( max(left partition) + min(right partition)  ) / 2</p> <p>If the array is odd lengthed : <pre><code>[1 2 3 4 5]\n     *\n</code></pre> We can consider the middle element to belong to both partitions. In which case <pre><code>[1 2 3 4 5]\n     *\n</code></pre></p> <p>The middle element IS the median i.e. index len(arr)//2</p> <p>We can always find partitions on A and B such that elements to the left of both partitions are less than elements to their right.</p> <pre><code>Example 1: \nB [ 1, 2, |6, 7]  # right pertition is inclusive\nA  [  5, |10  ]\n\n1,2,5  &lt; 6,7,10\n</code></pre> <pre><code>Example 2 :\nB [ |5, 6, 7, 8, 9 ] # consider left out of bounds position to be -inf and right out of bounds position to be +inf\n\nA [ 1, 2, 3, 4| ]\n\n1,2,3,4 &lt; 5,6,7,8,9\n</code></pre> <p>If we find the correct partitions like this, we can calculate the mean,</p> <p>The first question is how should we define the partitions?</p> <p>partition_a + partition_b = (m+n+1) //2 OR partition_a + partition_b = (m+n) // 2 </p> <p>let len(A) =m and len(B) = n </p> <p>FOR ODD LENGTHED ARRAY :</p> <pre><code>B  [1]   ; #IFF partition_b = (m+n +1 )//2 - partition_a  = 2//2 -0 = 1 But *IFF partition_b =  (m+n)//2 - partition_a =  1//2 -0 = 0-0 = 0 \n   *0 #1  \nA  [ ]   ; partition_a = (0+ 0)//2 =0 \n    0\n</code></pre> <p>If we say that partition_x + partition_y = (m+n)//2 then median is in the right partition in case of odd lengthed array.</p> <p>If we say that partition_x + partition_y = (m+n+1)//2 then median is in the left partition in case of odd lenghted array.</p> <p>It makes no difference for arrays where m+n is even. <pre><code>B [1 2]   ; #IFF partition_b = (m+n+1)//2 - partition_a  = 5//2 - 1 = 2- 1 = 1 and *IFF partition_b = (m+n)//2 - partition_a = 4//2 -1 = 1\n    #*1\nA [1 2]   ; partition_a = (0 + 2) // 2 = 1\n</code></pre></p> <p>Lets pick one convention : </p> <p>partition_a + partition_b = (m+n) //2</p> <p>Now for the binary search:</p> <p>It makes sense to binary search on the smaller array. Lets call this array A and the partition on it,  partition_a.</p> <p>For each partition_a we ask is left_b &gt; partition_a. If this is TRUE, then partition_a cannot be the pivot and needs to be moved right i.e. made larger.</p> <pre><code> INIT:         \n [ 1  3  4  5   6  ]\n  [ 2  6  7   8   ] \n    lo          hi\nITER 1:\n [1  3  4  5  6  ]\n        *            #left_b is 3.\n  [ 2 6 7  8 ]  \n   lo   *            #3 &gt; 7 is F; this could be the right partition_a ; hi = mid\n       F/hi\nITER 2 :\n [1  3  4  5  6  ]\n           *\n  [ 2  6 7  8 ]\n   lo  *           #4&gt; 6 is F  ; this could be partition_a hi = mid            \n      F/hi\nITER 3 :\n [1  3  4  5  6  ]\n              *\n  [ 2    6  7  8 ]\n    *              #5&gt;2 T; This cannot be the right partition_a ;\n    T/lo hi        #lo = mid+1  ; loop exits in next iteration\nITER 5 :\n[2     6   7   8]\n       *\n       F/lo,hi\nlo = hi = 1 and loop exits\n</code></pre> <p>Binary search will converge on first false value. <pre><code>   [1    3    4     |5    6  ]\n     [2     |6    7    8]\n      T     F    F    F\n</code></pre></p> <p>In our binary search we need a function move_right which simply returns left_b &gt; right_a</p> <p>Thats it. Once , we have the right partition, calculate mean:</p> <p>If (m+n) is odd : return min(right_a, right_b)</p> <p>If (m+n) is even : return (max(left_a, left_b) + min(right_a, right_b)) /2 </p>"},{"location":"iterative/2_binary_search/problems/median_of_two_sorted_arrays/LC_4__median_of_two_sorted_arrays/#code","title":"Code","text":"<p>```python3 [] class Solution:     def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:         # A is always the smaller array         A, B = nums1, nums2          if len(A) &gt; len(B) :             A , B = B, A</p> <pre><code>    #measure their lengths    \n    m,n = len(A), len(B)\n\n    def find_partition_b(partition_a) : \n        return (m+n)//2 - partition_a\n\n    def get_left(partition,array) :\n        return float('-inf') if (partition-1 )&lt;0 else array[partition-1]\n\n    def get_right(partition,array) :\n        return float('inf') if (partition)&gt;= len(array) else array[partition]\n\n    def move_right(partition_a) : \n        partition_b = find_partition_b(partition_a)\n        left_b = get_left(partition_b,B)\n        right_a = get_right(partition_a,A)\n        return left_b &gt; right_a\n\n    #binary search to find the correct partition_a\n    lo, hi  = 0 , len(A)\n    while lo &lt; hi :\n        partition_a = (lo +hi) // 2\n        if move_right(partition_a) :\n            lo = partition_a+1\n        else :\n            hi = partition_a\n\n    #lo and hi have converged on the correct partition_a \n    partition_a,partition_b   = lo, find_partition_b(lo)\n    right_a = get_right(partition_a,A)\n    right_b = get_right(partition_b,B)\n\n    #combined array length is odd\n    if (m+n) % 2 == 1 :\n        return min(right_a,right_b)\n\n    #combined array length is even    \n    left_a = get_left(partition_a,A)\n    left_b = get_left(partition_b,B)\n    return ( max(left_a,left_b) + min(right_a,right_b) ) / 2\n</code></pre> <p>```</p>"}]}